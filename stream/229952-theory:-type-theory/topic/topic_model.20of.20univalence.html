---
layout: archive
title: Zulip Chat Archive
permalink: /stream/229952-theory:-type-theory/topic/topic_model.20of.20univalence.html
---

<h2>Stream: <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory:-type-theory/index.html">theory: type theory</a></h2>
<h3>Topic: <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory:-type-theory/topic/topic_model.20of.20univalence.html">model of univalence</a></h3>

<hr>

<base href="https://categorytheory.zulipchat.com/">

{% raw %}

<a name="237489957"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/229952-theory%3A%20type%20theory/topic/model%20of%20univalence/near/237489957" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Leopold Schlicht <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory:-type-theory/topic/topic_model.20of.20univalence.html#237489957">(May 05 2021 at 12:56)</a>:</h4>
<p>Thanks!<br>
<span class="user-mention silent" data-user-id="276777">Mike Shulman</span> <a href="#narrow/stream/229952-theory.3A-type.20theory/topic/Model.20of.20univalence/near/237395068">said</a>:</p>
<blockquote>
<p>It's certainly not <em>literally</em> true in set theory, since we can make statements about a group <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span>, like <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∅</mi><mo>∈</mo><mi>G</mi></mrow><annotation encoding="application/x-tex">\emptyset \in G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">∅</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span> or <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo>=</mo><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">G = \mathbb{Z}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord mathbb">Z</span></span></span></span>, that can be true about some group but not about an isomorphic one.</p>
</blockquote>
<p>Of course (as you know), this only means that the principle isn't true in <em>material</em> set theory.<br>
What's wrong with adding the univalence principle to a more structural set theory like type theory (not treating it as a metatheorem!)?<br>
I just don't get why <em>spaces</em> should be so essential to univalence. :-)</p>



<a name="237492887"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/229952-theory%3A%20type%20theory/topic/model%20of%20univalence/near/237492887" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Leopold Schlicht <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory:-type-theory/topic/topic_model.20of.20univalence.html#237492887">(May 05 2021 at 13:16)</a>:</h4>
<p>Okay, directly adding it as an axiom rather than a metatheorem doesn't work because for that one needs an equality predicate on the universe.</p>



<a name="237493358"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/229952-theory%3A%20type%20theory/topic/model%20of%20univalence/near/237493358" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Hu <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory:-type-theory/topic/topic_model.20of.20univalence.html#237493358">(May 05 2021 at 13:20)</a>:</h4>
<p><span class="user-mention silent" data-user-id="275920">John Baez</span> <a href="#narrow/stream/229952-theory.3A-type.20theory/topic/Model.20of.20univalence/near/237413531">said</a>:</p>
<blockquote>
<blockquote>
<p>However, a metatheorem is significantly less convenient to use in practice than an actual theorem....</p>
</blockquote>
<p>I always wondered what exactly was the difference between a theorem and a metatheorem.   <span aria-label="upside down" class="emoji emoji-1f643" role="img" title="upside down">:upside_down:</span></p>
</blockquote>
<p>My understanding is something like this: A metatheorem is like a C macro, but for mathematics. Theorems in a formal system have to be finitely long, but some weird corners (particularly of set theory, e.g. Godel encoding etc.) end up making statements which would require the proofs to be infinitely long in full generality. However, every such instance of such a theorem would be specific enough to only need to be finitely long. This is resolved by having a metatheorem; i.e. a device to generate finite-length instances of such a theorem at whatever use-site you want</p>



<a name="237494157"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/229952-theory%3A%20type%20theory/topic/model%20of%20univalence/near/237494157" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Leopold Schlicht <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory:-type-theory/topic/topic_model.20of.20univalence.html#237494157">(May 05 2021 at 13:25)</a>:</h4>
<p>Maybe it doesn't explain all aspects of the term "metatheorem", but one analogy might be that a metatheorem is to a theorem what an axiom schema is to an axiom.<br>
A metatheorem might also be something like a "derivable" inference rule.<br>
This makes me think: What's wrong with "univalence" as a metatheorem? After all, nothing is wrong with inference rules!</p>



<a name="237494661"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/229952-theory%3A%20type%20theory/topic/model%20of%20univalence/near/237494661" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Hu <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory:-type-theory/topic/topic_model.20of.20univalence.html#237494661">(May 05 2021 at 13:28)</a>:</h4>
<p>I think there are two main considerations:</p>
<ol>
<li>people trying to make sense of univalence in ZFC models - if you add it as an axiom, it's not really obvious what the model is</li>
<li>people who think type theory should be constructive - univalence ought to have some computational meaning (and it is actually reasonably intuitive what this means), but adding it as an axiom does not resolve this. Cubical type theory however does</li>
</ol>



<a name="237495113"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/229952-theory%3A%20type%20theory/topic/model%20of%20univalence/near/237495113" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Hu <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory:-type-theory/topic/topic_model.20of.20univalence.html#237495113">(May 05 2021 at 13:31)</a>:</h4>
<p><span class="user-mention silent" data-user-id="408864">Leopold Schlicht</span> <a href="#narrow/stream/229952-theory.3A-type.20theory/topic/Model.20of.20univalence/near/237494157">said</a>:</p>
<blockquote>
<p>Maybe it doesn't explain all aspects of the term "metatheorem", but one analogy might be that a metatheorem is to a theorem what an axiom schema is to an axiom.<br>
A metatheorem might also be something like a "derivable" inference rule.<br>
This makes me think: What's wrong with "univalence" as a metatheorem? After all, nothing is wrong with inference rules!</p>
</blockquote>
<p>I don't think what you've said is correct. Comprehension in ZFC is an axiom schema, and I don't think anyone would call it 'meta'. 'Meta' is about using external reasoning outside of a formal system to derive facts about it</p>



<a name="237495768"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/229952-theory%3A%20type%20theory/topic/model%20of%20univalence/near/237495768" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mike Shulman <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory:-type-theory/topic/topic_model.20of.20univalence.html#237495768">(May 05 2021 at 13:36)</a>:</h4>
<p><span class="user-mention silent" data-user-id="408864">Leopold Schlicht</span> <a href="#narrow/stream/229952-theory.3A-type.20theory/topic/Model.20of.20univalence/near/237489957">said</a>:</p>
<blockquote>
<blockquote>
<p>It's certainly not <em>literally</em> true in set theory, since we can make statements about a group <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span>, like <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∅</mi><mo>∈</mo><mi>G</mi></mrow><annotation encoding="application/x-tex">\emptyset \in G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">∅</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span> or <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo>=</mo><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">G = \mathbb{Z}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord mathbb">Z</span></span></span></span>, that can be true about some group but not about an isomorphic one.</p>
</blockquote>
<p>Of course (as you know), this only means that the principle isn't true in <em>material</em> set theory.</p>
</blockquote>
<p>The example of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∅</mi><mo>∈</mo><mi>G</mi></mrow><annotation encoding="application/x-tex">\emptyset\in G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">∅</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span> is specific to material set theory, but <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo>=</mo><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">G=\mathbb{Z}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord mathbb">Z</span></span></span></span> is not.  As soon as you have a universe in a structural set theory, meaning a family of sets indexed by another set, then there is an equality relation on that family of sets, and you can make statements like <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo>=</mo><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">G=\mathbb{Z}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord mathbb">Z</span></span></span></span> that are not invariant under isomorphism.</p>
<p>Univalence only makes sense in type theory, where the "equality relation" on a type can be another <em>type</em> rather than a mere <em>relation</em>.</p>



<a name="237495866"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/229952-theory%3A%20type%20theory/topic/model%20of%20univalence/near/237495866" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mike Shulman <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory:-type-theory/topic/topic_model.20of.20univalence.html#237495866">(May 05 2021 at 13:36)</a>:</h4>
<blockquote>
<p>I just don't get why spaces should be so essential to univalence.</p>
</blockquote>
<p>Would you get it if we said "<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord">∞</span></span></span></span>-groupoids" instead of "spaces"?</p>



<a name="237507377"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/229952-theory%3A%20type%20theory/topic/model%20of%20univalence/near/237507377" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steve Awodey <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory:-type-theory/topic/topic_model.20of.20univalence.html#237507377">(May 05 2021 at 14:48)</a>:</h4>
<p>One familiar case that is true in Sets is the propositional one, where for subsets S, T c X of any set X, we have S = T iff S c T and T c S.  This is in fact a (very) special case of univalence.</p>



<a name="237514197"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/229952-theory%3A%20type%20theory/topic/model%20of%20univalence/near/237514197" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Scheel <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory:-type-theory/topic/topic_model.20of.20univalence.html#237514197">(May 05 2021 at 15:19)</a>:</h4>
<p>I think parametricity is a nice example of a metatheorem: for a lot of type theories, we have a metatheorem that any closed term <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi mathvariant="normal">∀</mi><mi>a</mi><mo separator="true">,</mo><mi>a</mi><mo>→</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">f : \forall a, a \to a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">∀</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span></span></span></span> must be the identity function. Why? Because we have no mechanism to write down anything else! But this fails once we have a mechanism for doing so, such as LEM. So metatheorems are true by looking at the syntax (initial model?), but fail to hold in all worlds modeled by the syntax. They assume it’s somehow a closed world.</p>
<p>Similarly in a language with only simple type formers (think ADTs like Haskell), we can prove metatheorems like “every syntactic type function <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>:</mo><mi>T</mi><mi>y</mi><mi>p</mi><mi>e</mi><mo>→</mo><mi>T</mi><mi>y</mi><mi>p</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">F : Type \to Type</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord mathnormal">p</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord mathnormal">p</span><span class="mord mathnormal">e</span></span></span></span> is an invariant Haskell-functor, in the sense that it admits an obvious function <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo>→</mo><mi>b</mi><mo stretchy="false">)</mo><mo>→</mo><mo stretchy="false">(</mo><mi>b</mi><mo>→</mo><mi>a</mi><mo stretchy="false">)</mo><mo>→</mo><mi>F</mi><mi>a</mi><mo>→</mo><mi>F</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">(a \to b) \to (b \to a) \to F a \to F b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal">b</span></span></span></span>”. How do we prove that? Well we just do induction on the syntax of how we defined each type or type function. But again this only works in a closed world. We could postulate type formers where this fails.</p>
<p>Metatheorems often look like “what you see is what you get”, but we know that’s not how logic works!</p>



<a name="237518848"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/229952-theory%3A%20type%20theory/topic/model%20of%20univalence/near/237518848" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Scheel <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory:-type-theory/topic/topic_model.20of.20univalence.html#237518848">(May 05 2021 at 15:48)</a>:</h4>
<p>Note how the metatheorem about invariant Haskell-functors starts looking like univalence: the metatheorem can give us functions in both directions between <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">F a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal">a</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">F b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal">b</span></span></span></span> (we have <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo>↔</mo><mi>b</mi><mo stretchy="false">)</mo><mo>→</mo><mo stretchy="false">(</mo><mi>F</mi><mi>a</mi><mo>↔</mo><mi>F</mi><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a \leftrightarrow b) \to (F a \leftrightarrow F b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">↔</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">↔</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span> as a corollary of the metatheorem), but we’re missing the proof that says we get an equivalence from an equivalence. Plus, we can only handle a small number of type formers. In particular, if we introduce equality types, our metatheorem breaks: we cannot produce a term of type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo>↔</mo><mi>b</mi><mo stretchy="false">)</mo><mo>→</mo><mo stretchy="false">(</mo><mi>x</mi><mo>=</mo><mi>a</mi><mo stretchy="false">)</mo><mo>→</mo><mo stretchy="false">(</mo><mi>x</mi><mo>=</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a \leftrightarrow b) \to (x = a) \to (x = b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">↔</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span>. So it’s really remarkable that univalence can work for all types, including function types, iterated identity types, higher inductive types.</p>



<a name="238140579"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/229952-theory%3A%20type%20theory/topic/model%20of%20univalence/near/238140579" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Hu <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory:-type-theory/topic/topic_model.20of.20univalence.html#238140579">(May 10 2021 at 13:21)</a>:</h4>
<p>Thanks for your insight John, it was a very interesting read. Especially what you said about 0#; it looks like something that programmers might describe as a 'hack', so I too am surprised to hear that mathematicians feel compelled that it must exist. I'm not sure if I would agree with you that it even seems like it ought to superficially exist - once you start talking about Godel numbers you are kind of in dangerous territory imo, but I guess that's just my preference for constructivism shining through</p>



<a name="238152086"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/229952-theory%3A%20type%20theory/topic/model%20of%20univalence/near/238152086" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mike Shulman <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory:-type-theory/topic/topic_model.20of.20univalence.html#238152086">(May 10 2021 at 14:34)</a>:</h4>
<p>I don't have any objection to material set theory as a subject; there are a lot of amazing things you can do with it, and it's certainly a more convenient context in which to study well-founded relations than building them explicitly in a structural framework, and that can have important ramifications for the rest of mathematics too.  For instance, whether or not <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">L</span></span></span></span> is all of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span>, its construction is still the only way I know of to prove that CH is consistent, and as far as I know no one has come up with a convincing structural version of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">L</span></span></span></span>.  I only object to claims that material set theory is the <em>only</em> foundation for mathematics, or a better one for all purposes.</p>



<a name="238168125"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/229952-theory%3A%20type%20theory/topic/model%20of%20univalence/near/238168125" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> John Baez <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory:-type-theory/topic/topic_model.20of.20univalence.html#238168125">(May 10 2021 at 16:08)</a>:</h4>
<p><span class="user-mention silent" data-user-id="280859">Nick Hu</span> <a href="#narrow/stream/229952-theory.3A-type.20theory/topic/model.20of.20univalence/near/238140579">said</a>:</p>
<blockquote>
<p>I'm not sure if I would agree with you that it even seems like it ought to superficially exist - once you start talking about Godel numbers you are kind of in dangerous territory imo, but I guess that's just my preference for constructivism shining through.</p>
</blockquote>
<p>Well, I guess all of classical set theory and model theory is dangerous territory then.  <span aria-label="upside down" class="emoji emoji-1f643" role="img" title="upside down">:upside_down:</span>    Gödel numbers are used for absolutely everything.</p>
<p>I don't think there's anything innately nonconstructive about Gödel numbers.  They're just a trick that shows up when a system gets powerful enough to reason about itself.  But classical logic is full of nonconstructive reasoning.</p>



<a name="238198754"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/229952-theory%3A%20type%20theory/topic/model%20of%20univalence/near/238198754" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Leopold Schlicht <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory:-type-theory/topic/topic_model.20of.20univalence.html#238198754">(May 10 2021 at 19:31)</a>:</h4>
<p><span class="user-mention silent" data-user-id="276777">Mike Shulman</span> <a href="#narrow/stream/229952-theory.3A-type.20theory/topic/model.20of.20univalence/near/238048249">said</a>:</p>
<blockquote>
<p>Well, the notion of "world" is not precise here, and hence neither is the notion of "translation between worlds".  One example would be a functor between toposes (logical, or perhaps geometric -- each with different behavior).  Another example is the construction of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">L</span></span></span></span> inside <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span>, or the construction of a model of ZFC inside a topos.</p>
</blockquote>
<p>Okay, thanks.</p>
<blockquote>
<p>Innumerable ways.  A functor maps objects of one world to objects of the other, so you can ask what constructions it preserves or reflects, and use it to deduce things about one world from properties of the other.</p>
</blockquote>
<p>Doesn't sound like "innumerable ways" to me, probably because I'm lacking the experience. :-) What would it imply when a translation preserves or reflects a construction?</p>
<p><span class="user-mention silent" data-user-id="275920">John Baez</span> <a href="#narrow/stream/229952-theory.3A-type.20theory/topic/model.20of.20univalence/near/237693582">said</a>:</p>
<blockquote>
<p>but I don't know if anyone has come up with a globular model of HoTT yet. </p>
</blockquote>
<p>By the way what is a "globular" model?</p>



<a name="238202384"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/229952-theory%3A%20type%20theory/topic/model%20of%20univalence/near/238202384" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Steve Awodey <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory:-type-theory/topic/topic_model.20of.20univalence.html#238202384">(May 10 2021 at 19:59)</a>:</h4>
<p><span class="user-mention silent" data-user-id="341237">Fawzi Hreiki</span> <a href="#narrow/stream/229952-theory.3A-type.20theory/topic/model.20of.20univalence/near/237976069">said</a>:</p>
<blockquote>
<p>Well with PA, if we're working in some ambient set theory, we could say that the intended model is the model picked out uniquely (up to iso) by second order PA (or by the NNO axioms). However, Joel Hamkins has mentioned somewhere that even this depends on the ambient set theory and so from the POV of another set theory, this 'actual' set of natural numbers is non-standard</p>
</blockquote>
<p>I would like to make two comments here:</p>
<p>(1) The fact that there are different models of PA just shows that we need to also include the ambient "setting" interpreting the induction axiom in the axiomatization - this is what we do in topos theory, where the notion of an NNO (or model of 2nd-order PA in the internal logic) becomes categorical (in the strong sense of model theory: any two models are - uniquely! - isomorphic).  This is a perfectly satisfactory situation - each topos has an essentially unique NNO.  Now one can of course ask further about comparing different toposes,  but there is no expectation that these are all equivalent (much less isomorphic).   The fact that the RE deductive system of second-order PA is deductively complete w/resp. to such topos models (indeed, w/resp. to just the well-pointed toposes, and therefore models of Mac Lane set theory) is again a perfectly satisfactory situation.  What more could you coherently want?</p>
<p>(2) I think there should be a principle of Reductio ad Gödelium in the philosophy of mathematics, like the Reductio ad Hitlerium in history.  The person who first plays the Gödel card loses the argument.</p>



<a name="238229767"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/229952-theory%3A%20type%20theory/topic/model%20of%20univalence/near/238229767" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> John Baez <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory:-type-theory/topic/topic_model.20of.20univalence.html#238229767">(May 10 2021 at 23:58)</a>:</h4>
<p><span class="user-mention silent" data-user-id="408864">Leopold Schlicht</span> <a href="#narrow/stream/229952-theory.3A-type.20theory/topic/model.20of.20univalence/near/238198754">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="275920">John Baez</span> <a href="#narrow/stream/229952-theory.3A-type.20theory/topic/model.20of.20univalence/near/237693582">said</a>:</p>
<blockquote>
<p>but I don't know if anyone has come up with a globular model of HoTT yet. </p>
</blockquote>
<p>By the way what is a "globular" model?</p>
</blockquote>



<a name="238556963"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/229952-theory%3A%20type%20theory/topic/model%20of%20univalence/near/238556963" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mike Shulman <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory:-type-theory/topic/topic_model.20of.20univalence.html#238556963">(May 12 2021 at 23:03)</a>:</h4>
<p><span class="user-mention silent" data-user-id="276777">Mike Shulman</span> <a href="#narrow/stream/229952-theory.3A-type.20theory/topic/model.20of.20univalence/near/238047944">said</a>:</p>
<blockquote>
<p>I can't find the reference right now, but I think I remember that Lawvere considered <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>V</mi><mo>=</mo><mi>L</mi><mo stretchy="false">)</mo><mo>⇒</mo><mrow><mi mathvariant="normal">C</mi><mi mathvariant="normal">H</mi></mrow></mrow><annotation encoding="application/x-tex">(V=L) \Rightarrow \rm CH</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathrm">CH</span></span></span></span></span> as settling the continuum hypothesis positively for "constant sets".</p>
</blockquote>
<p>Found it: it's in "Cohesive  Toposes  and  Cantor's 'lauter Einsen'".</p>
<blockquote>
<p>The dialectic reflected  in this method  is that  between  imagined  Being in general with  all its  interlocking  categories  of cohesion and  variation  on  the one hand and the extreme special case  of discreteness and constancy  on the other.  Proper  understanding  of this dialectic may put  into a  different  light debates  over  'foundational'  questions  such  as  whether  there  is  an  infinite set  of  reals  of  cardinality  less  than  the  continuum,  or  whether  there  is  a large  measurable  cardinal.  The  answers  are  clearly  <em>no</em>  if  we are  pursuing constancy  toward  an  extreme, because  Godel's  L  construction  would  otherwise  give  us  something  still  more constant.... On the  other  hand,  the  answer  is clearly  <em>yes</em>, the  GCH  is  false,  if  we are  considering  almost  any  cohesive variable  topos  of  independent  mathematical interest. </p>
</blockquote>



<a name="238565889"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/229952-theory%3A%20type%20theory/topic/model%20of%20univalence/near/238565889" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> David Michael Roberts <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory:-type-theory/topic/topic_model.20of.20univalence.html#238565889">(May 13 2021 at 00:50)</a>:</h4>
<p>Maybe <em>rigid</em>, in a non-technical sense, is a good synonym for "constant" here, since <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">L</span></span></span></span> is even more highly constrained than <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> (which is rigid in a technical sense).</p>



<a name="238594102"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/229952-theory%3A%20type%20theory/topic/model%20of%20univalence/near/238594102" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> James Wood <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory:-type-theory/topic/topic_model.20of.20univalence.html#238594102">(May 13 2021 at 08:16)</a>:</h4>
<p>Ah, sorry, I completely forgot the details of the <em>bi</em>modules example!</p>



<a name="238597300"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/229952-theory%3A%20type%20theory/topic/model%20of%20univalence/near/238597300" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Fawzi Hreiki <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory:-type-theory/topic/topic_model.20of.20univalence.html#238597300">(May 13 2021 at 08:58)</a>:</h4>
<p>I think there’s more on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo>=</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">V = L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">L</span></span></span></span> in ‘<a href="https://github.com/mattearnshaw/lawvere/blob/master/pdfs/2003-foundations-and-applications-axiomatization-and-education.pdf">Foundations and Applications</a>’</p>



<a name="240535782"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/229952-theory%3A%20type%20theory/topic/model%20of%20univalence/near/240535782" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Leopold Schlicht <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory:-type-theory/topic/topic_model.20of.20univalence.html#240535782">(May 27 2021 at 21:41)</a>:</h4>
<p>Somewhat related to the discussion at the beginning of this thread: can one find a precise definition of when a first-order formula <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\phi(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ϕ</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span> in the language of ZFC is "a structural, isomorphism-invariant property" and then prove the following metatheorem: whenever ZFC proves such a property for some set <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span></span></span></span> and proves <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>≅</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a\cong b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.589em;vertical-align:0em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span>, then ZFC proves <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\phi(b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ϕ</span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span>? (Of course, this statement should really be formulated allowing <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\phi(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ϕ</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span> to contain parameters.)<br>
(This question reminds me of the purely syntactic definition, which is due to Freyd I think, of when a first-order sentence <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">\phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">ϕ</span></span></span></span> in the language of a single category is invariant under equivalence of categories. I can't recall the details off the top of my head, but one requirement should be that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">\phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">ϕ</span></span></span></span> doesn't talk about equality of objects, another that only parallel morphisms are compared, roughly speaking. Then one can prove that each such <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">\phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">ϕ</span></span></span></span> is indeed invariant under equivalence. As a minor question: can one prove something like a converse of that statement? Can there be nontrivial <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">\phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">ϕ</span></span></span></span> that don't satisfy this syntactic property, but are nevertheless invariant under equivalence? Of course there are trivial examples like <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>A</mi><mi mathvariant="normal">.</mi><mtext> </mtext><mi>A</mi><mo>=</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">\forall A.\, A=A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">∀</span><span class="mord mathnormal">A</span><span class="mord">.</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span>.)</p>



<a name="240537253"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/229952-theory%3A%20type%20theory/topic/model%20of%20univalence/near/240537253" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Leopold Schlicht <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory:-type-theory/topic/topic_model.20of.20univalence.html#240537253">(May 27 2021 at 21:54)</a>:</h4>
<p>Also, what's wrong with just adding <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mspace></mspace><mspace width="0.1111111111111111em"/><mo lspace="0em" rspace="0.17em"></mo><mtext> ⁣</mtext><mo lspace="0em" rspace="0em">:</mo><mspace width="0.3333333333333333em"/><mi mathvariant="script">U</mi><mi mathvariant="normal">.</mi><mtext> </mtext><mrow><mi>A</mi><mo>≅</mo><mi>B</mi></mrow><mo>→</mo><mi>A</mi><msub><mo>=</mo><mi mathvariant="script">U</mi></msub><mi>B</mi></mrow><annotation encoding="application/x-tex">\forall A,B\colon\mathcal U.\, {A \cong B} \to A=_{\mathcal U}B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">∀</span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace nobreak"></span><span class="mspace" style="margin-right:0.1111111111111111em;"></span><span class="mpunct"></span><span class="mspace" style="margin-right:-0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mrel">:</span></span><span class="mspace" style="margin-right:0.3333333333333333em;"></span><span class="mord mathcal" style="margin-right:0.09931em;">U</span><span class="mord">.</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel">=</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathcal mtight" style="margin-right:0.09931em;">U</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> instead of univalence (where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>≅</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A\cong B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> is the type of equivalences between <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>)?<br>
Maybe that's related to what Mike was referring to when he said:</p>
<blockquote>
<p>Another answer is that you don't need things like homotopy theory and Kan complexes if you only want to apply univalence to isomorphism of <em>set-based</em> structures such as groups, rings, fields, etc.  For that purpose, it suffices to use a version of HoTT in which only the universe of sets is univalent, and that theory can be modeled using plain ordinary groupoids (as shown by Hofmann and Streicher in 1998).</p>
</blockquote>
<p>But to model the above axiom, I would think one doesn't need groupoids.</p>



<a name="240555206"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/229952-theory%3A%20type%20theory/topic/model%20of%20univalence/near/240555206" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mike Shulman <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory:-type-theory/topic/topic_model.20of.20univalence.html#240555206">(May 28 2021 at 02:28)</a>:</h4>
<p>I don't know of a characterization in terms of ZFC syntax, but a usefully broad class of isomorphism-invariant formulas is those that arise from a dependently typed formulation of ETCS along the lines of Freyd's theorem that you mention.  See for instance Lemma 3.4 of my paper <a href="https://arxiv.org/abs/1808.05204v2">Comparing material and structural set theories</a>.</p>



<a name="240555243"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/229952-theory%3A%20type%20theory/topic/model%20of%20univalence/near/240555243" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mike Shulman <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory:-type-theory/topic/topic_model.20of.20univalence.html#240555243">(May 28 2021 at 02:29)</a>:</h4>
<p><span class="user-mention silent" data-user-id="408864">Leopold Schlicht</span> <a href="#narrow/stream/229952-theory.3A-type.20theory/topic/model.20of.20univalence/near/240537253">said</a>:</p>
<blockquote>
<p>Also, what's wrong with just adding <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mspace></mspace><mspace width="0.1111111111111111em"/><mo lspace="0em" rspace="0.17em"></mo><mtext> ⁣</mtext><mo lspace="0em" rspace="0em">:</mo><mspace width="0.3333333333333333em"/><mi mathvariant="script">U</mi><mi mathvariant="normal">.</mi><mtext> </mtext><mrow><mi>A</mi><mo>≅</mo><mi>B</mi></mrow><mo>→</mo><mi>A</mi><msub><mo>=</mo><mi mathvariant="script">U</mi></msub><mi>B</mi></mrow><annotation encoding="application/x-tex">\forall A,B\colon\mathcal U.\, {A \cong B} \to A=_{\mathcal U}B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">∀</span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace nobreak"></span><span class="mspace" style="margin-right:0.1111111111111111em;"></span><span class="mpunct"></span><span class="mspace" style="margin-right:-0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mrel">:</span></span><span class="mspace" style="margin-right:0.3333333333333333em;"></span><span class="mord mathcal" style="margin-right:0.09931em;">U</span><span class="mord">.</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel">=</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathcal mtight" style="margin-right:0.09931em;">U</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> instead of univalence?</p>
</blockquote>
<p>You may be able to interpret this in a "skeletal" set-theoretic model, although it's not entirely trivial; I think there was some discussion of this on the HoTT mailing list some time ago.  However, it's not a very useful axiom compared to univalence, since when two things are isomorphic, in order to get a meaningful statement about one from a statement about the other, we often need to transfer across <em>the specific isomorphism</em> that we're interested in.</p>



<a name="240578157"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/229952-theory%3A%20type%20theory/topic/model%20of%20univalence/near/240578157" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Leopold Schlicht <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory:-type-theory/topic/topic_model.20of.20univalence.html#240578157">(May 28 2021 at 09:02)</a>:</h4>
<p>Ah, I see, thanks!</p>



<a name="240919758"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/229952-theory%3A%20type%20theory/topic/model%20of%20univalence/near/240919758" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Leopold Schlicht <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory:-type-theory/topic/topic_model.20of.20univalence.html#240919758">(Jun 01 2021 at 10:04)</a>:</h4>
<p>What have models of HoTT in cubical sets to do with computational properties like canonicity or normalization? Models of HoTT are semantical things, while computational properties are rather syntactical concepts, so I don't see any connection.</p>



<a name="240923855"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/229952-theory%3A%20type%20theory/topic/model%20of%20univalence/near/240923855" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nick Hu <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory:-type-theory/topic/topic_model.20of.20univalence.html#240923855">(Jun 01 2021 at 10:49)</a>:</h4>
<p>We know how to do all these computational things for cubical. So far, it's not known for other flavours how to do so</p>



<a name="240939649"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/229952-theory%3A%20type%20theory/topic/model%20of%20univalence/near/240939649" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mike Shulman <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory:-type-theory/topic/topic_model.20of.20univalence.html#240939649">(Jun 01 2021 at 13:17)</a>:</h4>
<p>When you define a "constructive" model of HoTT, the ambient computation of the constructive metatheory gives you a way to evaluate terms: first interpret them in the model and then compute in the metatheory.  Historically, at least, this was a "first step" towards giving intrinsic notions of computation for the cubical theory such as canonicity and normalization.</p>



<a name="240942471"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/229952-theory%3A%20type%20theory/topic/model%20of%20univalence/near/240942471" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Leopold Schlicht <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory:-type-theory/topic/topic_model.20of.20univalence.html#240942471">(Jun 01 2021 at 13:36)</a>:</h4>
<p>Interesting, so using a constructive metatheory one can show that cubical sets are a model of HoTT, while one needs a classical metatheory to prove that Kan complexes are a model of HoTT, roughly speaking?</p>



<a name="240948513"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/229952-theory%3A%20type%20theory/topic/model%20of%20univalence/near/240948513" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mike Shulman <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory:-type-theory/topic/topic_model.20of.20univalence.html#240948513">(Jun 01 2021 at 14:17)</a>:</h4>
<p>That's the current state of the art.</p>



<a name="241712203"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/229952-theory%3A%20type%20theory/topic/model%20of%20univalence/near/241712203" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Leopold Schlicht <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory:-type-theory/topic/topic_model.20of.20univalence.html#241712203">(Jun 06 2021 at 21:42)</a>:</h4>
<p>Can the univalence axiom be formulated as <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∏</mo><mrow><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mspace></mspace><mspace width="0.1111111111111111em"/><mo lspace="0em" rspace="0.17em"></mo><mtext> ⁣</mtext><mo lspace="0em" rspace="0em">:</mo><mspace width="0.3333333333333333em"/><mi mathvariant="script">U</mi></mrow></msub><mi mathvariant="normal">.</mi><mtext> </mtext><mo stretchy="false">∥</mo><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">o</mi></mrow><mo stretchy="false">(</mo><msub><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">q</mi></mrow><mrow><mi>A</mi><mo separator="true">,</mo><mi>B</mi></mrow></msub><mo stretchy="false">)</mo><msub><mo stretchy="false">∥</mo><mrow><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">\prod_{A,B\colon\mathcal U}.\, \lVert\mathrm{isiso}(\mathrm{idtoeq}_{A,B})\rVert_{-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.185818em;vertical-align:-0.43581800000000004em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∏</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.17862099999999992em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">A</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span><span class="mspace nobreak mtight"></span><span class="mspace mtight" style="margin-right:0.13011111111111112em;"></span><span class="mpunct mtight"></span><span class="mord mtight"><span class="mrel mtight">:</span></span><span class="mspace mtight" style="margin-right:0.39033333333333337em;"></span><span class="mord mathcal mtight" style="margin-right:0.09931em;">U</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.43581800000000004em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">∥</span><span class="mord"><span class="mord mathrm">isiso</span></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord mathrm">idtoeq</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.23419099999999998em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">A</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.380248em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose"><span class="mclose">∥</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>?</p>



<a name="241716914"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/229952-theory%3A%20type%20theory/topic/model%20of%20univalence/near/241716914" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mike Shulman <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory:-type-theory/topic/topic_model.20of.20univalence.html#241716914">(Jun 06 2021 at 23:57)</a>:</h4>
<p>I assume by 'isiso' you mean what the book calls 'qinv', and that the codomain of your 'idtoeq' is a correct definition of equivalence.  In this case, the answer is yes at least if you assume funext, since then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∥</mi><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">o</mi></mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><msub><mi mathvariant="normal">∥</mi><mrow><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">\Vert \mathrm{isiso}(f)\Vert_{-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∥</span><span class="mord"><span class="mord mathrm">isiso</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mord"><span class="mord">∥</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span> is equivalent to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">q</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">v</mi></mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{isequiv}(f)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm" style="margin-right:0.01389em;">isequiv</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span></span>.  I'm not sure offhand whether this version suffices to prove funext from univalence; you'd have to trace through the proof.</p>



<a name="241761226"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/229952-theory%3A%20type%20theory/topic/model%20of%20univalence/near/241761226" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Leopold Schlicht <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory:-type-theory/topic/topic_model.20of.20univalence.html#241761226">(Jun 07 2021 at 11:24)</a>:</h4>
<p>Oh, I actually meant <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∏</mo><mrow><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mspace></mspace><mspace width="0.1111111111111111em"/><mo lspace="0em" rspace="0.17em"></mo><mtext> ⁣</mtext><mo lspace="0em" rspace="0em">:</mo><mspace width="0.3333333333333333em"/><mi mathvariant="script">U</mi></mrow></msub><mi mathvariant="normal">.</mi><mtext> </mtext><mo stretchy="false">∥</mo><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">o</mi></mrow><mo stretchy="false">(</mo><msub><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">o</mi></mrow><mrow><mi>A</mi><mo separator="true">,</mo><mi>B</mi></mrow></msub><mo stretchy="false">)</mo><msub><mo stretchy="false">∥</mo><mrow><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">\prod_{A,B\colon\mathcal U}.\, \lVert\mathrm{isiso}(\mathrm{idtoiso}_{A,B})\rVert_{-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.185818em;vertical-align:-0.43581800000000004em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∏</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.17862099999999992em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">A</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span><span class="mspace nobreak mtight"></span><span class="mspace mtight" style="margin-right:0.13011111111111112em;"></span><span class="mpunct mtight"></span><span class="mord mtight"><span class="mrel mtight">:</span></span><span class="mspace mtight" style="margin-right:0.39033333333333337em;"></span><span class="mord mathcal mtight" style="margin-right:0.09931em;">U</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.43581800000000004em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">∥</span><span class="mord"><span class="mord mathrm">isiso</span></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord mathrm">idtoiso</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.328331em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">A</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose"><span class="mclose">∥</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>, where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">o</mi></mrow><mrow><mi>A</mi><mo separator="true">,</mo><mi>B</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\mathrm{idtoiso}_{A,B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">idtoiso</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.328331em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">A</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> is the canonical map of type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><msub><mo>=</mo><mi mathvariant="script">U</mi></msub><mi>B</mi><mo>→</mo><mi>A</mi><mo>≅</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A=_{\mathcal U}B\to A\cong B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel">=</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathcal mtight" style="margin-right:0.09931em;">U</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>≅</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A\cong B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∑</mo><mrow><mi>f</mi><mspace></mspace><mspace width="0.1111111111111111em"/><mo lspace="0em" rspace="0.17em"></mo><mtext> ⁣</mtext><mo lspace="0em" rspace="0em">:</mo><mspace width="0.3333333333333333em"/><mi>A</mi><mo>→</mo><mi>B</mi></mrow></msub><mi mathvariant="normal">.</mi><mtext> </mtext><mo stretchy="false">∥</mo><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">o</mi></mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><msub><mo stretchy="false">∥</mo><mrow><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">\sum_{f\colon A\to B}.\, \lVert \mathrm{isiso}(f)\rVert_{-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.185818em;vertical-align:-0.43581800000000004em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.18639799999999984em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mspace nobreak mtight"></span><span class="mspace mtight" style="margin-right:0.13011111111111112em;"></span><span class="mpunct mtight"></span><span class="mord mtight"><span class="mrel mtight">:</span></span><span class="mspace mtight" style="margin-right:0.39033333333333337em;"></span><span class="mord mathnormal mtight">A</span><span class="mrel mtight">→</span><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.43581800000000004em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">∥</span><span class="mord"><span class="mord mathrm">isiso</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mclose"><span class="mclose">∥</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>, and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">o</mi></mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{isiso}(f)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">isiso</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span></span> is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∑</mo><mrow><mi>g</mi><mspace></mspace><mspace width="0.1111111111111111em"/><mo lspace="0em" rspace="0.17em"></mo><mtext> ⁣</mtext><mo lspace="0em" rspace="0em">:</mo><mspace width="0.3333333333333333em"/><mi>B</mi><mo>→</mo><mi>A</mi></mrow></msub><mi mathvariant="normal">.</mi><mtext> </mtext><mo stretchy="false">(</mo><mi>g</mi><mo>∘</mo><mi>f</mi><mo>=</mo><msub><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">d</mi></mrow><mi>A</mi></msub><mo stretchy="false">)</mo><mo>×</mo><mo stretchy="false">(</mo><mi>f</mi><mo>∘</mo><mi>g</mi><mo>=</mo><msub><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">d</mi></mrow><mi>B</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sum_{g\colon B\to A}.\, (g\circ f=\mathrm{id}_A)\times (f\circ g=\mathrm{id}_B)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.185818em;vertical-align:-0.43581800000000004em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.17862099999999992em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span><span class="mspace nobreak mtight"></span><span class="mspace mtight" style="margin-right:0.13011111111111112em;"></span><span class="mpunct mtight"></span><span class="mord mtight"><span class="mrel mtight">:</span></span><span class="mspace mtight" style="margin-right:0.39033333333333337em;"></span><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span><span class="mrel mtight">→</span><span class="mord mathnormal mtight">A</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.43581800000000004em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∘</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">id</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∘</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">id</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>. The motivation of my question is to formulate the univalence axiom without Voevodsky's tricky notion of equivalence that magically happens to make <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">q</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">v</mi></mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{isequiv}(f)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm" style="margin-right:0.01389em;">isequiv</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span></span> a mere proposition (at the cost of assuming the existence of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">∥</mo><mo>⋅</mo><msub><mo stretchy="false">∥</mo><mrow><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">\lVert\cdot\rVert_{-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">∥</span><span class="mord">⋅</span><span class="mclose"><span class="mclose">∥</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>-truncation). Maybe such a formulation would be both conceptually and pedagogically simpler.</p>



<a name="241769708"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/229952-theory%3A%20type%20theory/topic/model%20of%20univalence/near/241769708" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jonathan Sterling <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory:-type-theory/topic/topic_model.20of.20univalence.html#241769708">(Jun 07 2021 at 12:39)</a>:</h4>
<p>I personally don't think that such a formulation would be conceptually or pedagogically simpler.  Voevodksy's formulation of equivalences looks unfamiliar when you use words like "contractible" and "fiber" or whatever, but it is also very natural from the perspective of the naïve "input-output blob" diagrams that they use to teach pre-teens the notion of surjective and injective and bijective functions...</p>



<a name="241769766"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/229952-theory%3A%20type%20theory/topic/model%20of%20univalence/near/241769766" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jonathan Sterling <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory:-type-theory/topic/topic_model.20of.20univalence.html#241769766">(Jun 07 2021 at 12:39)</a>:</h4>
<p>(I do not mean to downplay the importance of Voevodsky's definition --- I just mean that it is not as alien as you might think)</p>



<a name="241771881"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/229952-theory%3A%20type%20theory/topic/model%20of%20univalence/near/241771881" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mike Shulman <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory:-type-theory/topic/topic_model.20of.20univalence.html#241771881">(Jun 07 2021 at 12:57)</a>:</h4>
<blockquote>
<p>Oh, I actually meant</p>
</blockquote>
<p>That's also correct if you assume funext separately, for the same reason.</p>



<a name="241772088"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/229952-theory%3A%20type%20theory/topic/model%20of%20univalence/near/241772088" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mike Shulman <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory:-type-theory/topic/topic_model.20of.20univalence.html#241772088">(Jun 07 2021 at 12:59)</a>:</h4>
<p>However, apart from questions of "simplicity" which can be debated, there is an important mathematical point that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∥</mi><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">o</mi></mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><msub><mi mathvariant="normal">∥</mi><mrow><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">\Vert \mathrm{isiso}(f)\Vert_{-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∥</span><span class="mord"><span class="mord mathrm">isiso</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mord"><span class="mord">∥</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span> is not a very <em>useful</em> definition of equivalence, because you can't extract an inverse function from it without essentially giving one of the correct definitions of equivalence and proving its equivalence to that.</p>



<a name="241788521"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/229952-theory%3A%20type%20theory/topic/model%20of%20univalence/near/241788521" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Leopold Schlicht <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory:-type-theory/topic/topic_model.20of.20univalence.html#241788521">(Jun 07 2021 at 14:54)</a>:</h4>
<p>Thanks!</p>



<a name="244015853"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/229952-theory%3A%20type%20theory/topic/model%20of%20univalence/near/244015853" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Leopold Schlicht <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory:-type-theory/topic/topic_model.20of.20univalence.html#244015853">(Jun 26 2021 at 13:44)</a>:</h4>
<p><span class="user-mention silent" data-user-id="276777">Mike Shulman</span> <a href="#narrow/stream/229952-theory.3A-type.20theory/topic/model.20of.20univalence/near/237394436">said</a>:</p>
<blockquote>
<p>Another answer is that you don't need things like homotopy theory and Kan complexes if you only want to apply univalence to isomorphism of set-based structures such as groups, rings, fields, etc. For that purpose, it suffices to use a version of HoTT in which only the universe of sets is univalent, and that theory can be modeled using plain ordinary groupoids (as shown by Hofmann and Streicher in 1998). It's only when you want to start applying univalence to equivalence of categorical structures that you need higher categorical models</p>
</blockquote>
<p>Why, actually, does one need higher categorical models in order to apply univalence to equivalence of categories? Simply because one wants that there's a category of sets (whose underlying type of objects isn't a set) or did you have further reasons in mind when writing this?</p>
<p>I guess the "version of HoTT in which only the universe of sets is univalent" you are referring to is MLTT with so-called universe extensionality. At the moment I am a bit confused, because isn't Exercise 4.6 in the book saying that universe extensionality is inconsistent?</p>
<p>Is there a conceptual reason for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">q</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">v</mi></mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{isequiv}(f)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm" style="margin-right:0.01389em;">isequiv</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span></span> to be a mere proposition? To me this seems to be a statement that just randomly happens to be true. But since this fact is so central to HoTT, I would like to hear a reason that is conceptually more pleasing, or any other simple motivation for the definition of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">q</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">v</mi></mrow><annotation encoding="application/x-tex">\mathrm{isequiv}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8623000000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathrm" style="margin-right:0.01389em;">isequiv</span></span></span></span></span>.</p>



<a name="244021117"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/229952-theory%3A%20type%20theory/topic/model%20of%20univalence/near/244021117" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mike Shulman <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory:-type-theory/topic/topic_model.20of.20univalence.html#244021117">(Jun 26 2021 at 15:47)</a>:</h4>
<p><span class="user-mention silent" data-user-id="408864">Leopold Schlicht</span> <a href="#narrow/stream/229952-theory.3A-type.20theory/topic/model.20of.20univalence/near/244015853">said</a>:</p>
<blockquote>
<p>Why, actually, does one need higher categorical models in order to apply univalence to equivalence of categories?</p>
</blockquote>
<p>Because applying univalence to equivalence of categories requires the categories to be "univalent" themselves, which requires their type of objects to be a 1-type.  So if there is a type <em>of</em> categories to which to apply univalence, it must be a 2-type.</p>
<blockquote>
<p>I guess the "version of HoTT in which only the universe of sets is univalent" you are referring to is MLTT with so-called universe extensionality.</p>
</blockquote>
<p>MLTT with <em>one</em> universe of sets that satisfies universe extensionality, or equivalently univalence (the two are equivalent for a universe of sets).</p>
<blockquote>
<p>At the moment I am a bit confused, because isn't Exercise 4.6 in the book saying that universe extensionality is inconsistent?</p>
</blockquote>
<p>It's inconsistent for a universe that contains non-sets.  (More specifically, particular non-sets such as the circle or a smaller universe.)</p>
<blockquote>
<p>Is there a conceptual reason for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">q</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">v</mi></mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{isequiv}(f)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm" style="margin-right:0.01389em;">isequiv</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span></span> to be a mere proposition?</p>
</blockquote>
<p>In set-based mathematics, isomorphisms and equivalences are universally defined to be morphisms with the <em>property</em> of being an isomorphism/equivalence.  In particular, if we want to show that two equivalences are the same, it suffices to show they are the same function; we don't have to separately argue that their "equivalence data" are the same.  Requiring isequiv to be a mere proposition achieves this same result in HoTT.</p>
<p>Plus, as Exercise 4.6 says, otherwise univalence is inconsistent.  (-:</p>



<a name="244181972"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/229952-theory%3A%20type%20theory/topic/model%20of%20univalence/near/244181972" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Leopold Schlicht <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory:-type-theory/topic/topic_model.20of.20univalence.html#244181972">(Jun 28 2021 at 17:55)</a>:</h4>
<p>Thanks!<br>
<span class="user-mention silent" data-user-id="276777">Mike Shulman</span> <a href="#narrow/stream/229952-theory.3A-type.20theory/topic/model.20of.20univalence/near/244021117">said</a>:</p>
<blockquote>
<p>Because applying univalence to equivalence of categories requires the categories to be "univalent" themselves, which requires their type of objects to be a 1-type.  So if there is a type <em>of</em> categories to which to apply univalence, it must be a 2-type.</p>
</blockquote>
<p>These two sentences somehow don't compile in my brain. What do you mean by "applying univalence to equivalence of categories"? What does it mean for a category to be "univalent"?</p>
<blockquote>
<p>Requiring isequiv to be a mere proposition achieves this same result in HoTT.</p>
</blockquote>
<p>I see, but this just explains why one wants isequiv(f) to be a mere proposition, and doesn't motivate Voevodsky's subtle definition of isequiv(f) and why it is a mere proposition. Of course, one could "justify" the definition by formally proving that it is a mere proposition. But I would like to know an intuitive reason for that and, moreover, understand why it is natural to come up with this definition. (My goal in <a href="#narrow/stream/229952-theory.3A-type.20theory/topic/model.20of.20univalence/near/241761226">https://categorytheory.zulipchat.com/#narrow/stream/229952-theory.3A-type.20theory/topic/model.20of.20univalence/near/241761226</a> was to propose another definition that I consider to be "natural", but as you pointed out, it isn't that useful.)</p>



<a name="244182413"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/229952-theory%3A%20type%20theory/topic/model%20of%20univalence/near/244182413" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mike Shulman <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory:-type-theory/topic/topic_model.20of.20univalence.html#244182413">(Jun 28 2021 at 17:58)</a>:</h4>
<blockquote>
<p>What do you mean by "applying univalence to equivalence of categories"? What does it mean for a category to be "univalent"?</p>
</blockquote>
<p>Have you read chapter 9 of the HoTT Book?</p>



<a name="244182861"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/229952-theory%3A%20type%20theory/topic/model%20of%20univalence/near/244182861" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Leopold Schlicht <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory:-type-theory/topic/topic_model.20of.20univalence.html#244182861">(Jun 28 2021 at 18:01)</a>:</h4>
<p>Sort of, but only parts of it in detail. <span aria-label="sweat smile" class="emoji emoji-1f605" role="img" title="sweat smile">:sweat_smile:</span></p>



<a name="244182888"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/229952-theory%3A%20type%20theory/topic/model%20of%20univalence/near/244182888" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mike Shulman <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory:-type-theory/topic/topic_model.20of.20univalence.html#244182888">(Jun 28 2021 at 18:01)</a>:</h4>
<p>It should answer those questions.</p>



<a name="244183078"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/229952-theory%3A%20type%20theory/topic/model%20of%20univalence/near/244183078" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mike Shulman <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory:-type-theory/topic/topic_model.20of.20univalence.html#244183078">(Jun 28 2021 at 18:03)</a>:</h4>
<blockquote>
<p>I see, but this just explains why one wants isequiv(f) to be a mere proposition, and doesn't motivate Voevodsky's subtle definition of isequiv(f) and why it is a mere proposition.</p>
</blockquote>
<p>Oh, I see I misread your question.  I thought you were asking "why <em>should</em> isequiv" be a proposition?" rather than "why <em>does</em> some particular definition of isequiv happen to be a proposition?".</p>
<p>If you're asking about Voevodsky's definition of isequiv, then the reason that's a proposition is because iscontr is a proposition.  As for why iscontr is a proposition, one way to understand this intuitively is that to prove a type is a proposition it suffices to assume it is inhabited.  But once iscontr(A) is inhabited, then A is contractible, and so pretty much anything we construct out of it will also be contractible, including iscontr(A).  Specifically, iscontr(A) consists of a center and a contraction, but when A is contractible, there is a contractible space of such points and a contractible space of contractions to any such point.</p>



<a name="244183231"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/229952-theory%3A%20type%20theory/topic/model%20of%20univalence/near/244183231" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mike Shulman <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory:-type-theory/topic/topic_model.20of.20univalence.html#244183231">(Jun 28 2021 at 18:04)</a>:</h4>
<p>For other definitions of isequiv, one can give different intuitions.  For instance, for a half-adjoint equivalence one can make an argument about how a ball has a CW-presentation with 2 cells at each dimension except 1 at the top.</p>



<a name="244184040"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/229952-theory%3A%20type%20theory/topic/model%20of%20univalence/near/244184040" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Leopold Schlicht <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229952-theory:-type-theory/topic/topic_model.20of.20univalence.html#244184040">(Jun 28 2021 at 18:10)</a>:</h4>
<p>That's exactly what I was asking for, thanks! :-)</p>



{% endraw %}

<hr><p>Last updated: Apr 11 2023 at 00:28 UTC</p>