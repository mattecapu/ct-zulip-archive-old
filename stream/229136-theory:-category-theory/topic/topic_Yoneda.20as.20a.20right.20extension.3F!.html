---
layout: archive
title: Zulip Chat Archive
permalink: /stream/229136-theory:-category-theory/topic/topic_Yoneda.20as.20a.20right.20extension.3F!.html
---

<h2>Stream: <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory:-category-theory/index.html">theory: category theory</a></h2>
<h3>Topic: <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory:-category-theory/topic/topic_Yoneda.20as.20a.20right.20extension.3F!.html">Yoneda as a right extension?!</a></h3>

<hr>

<base href="https://categorytheory.zulipchat.com/">

{% raw %}

<a name="311857796"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/229136-theory%3A%20category%20theory/topic/Yoneda%20as%20a%20right%20extension%3F%21/near/311857796" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Tom Hirschowitz <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory:-category-theory/topic/topic_Yoneda.20as.20a.20right.20extension.3F!.html#311857796">(Nov 23 2022 at 16:12)</a>:</h4>
<p>For any category <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">C</mi></mrow><annotation encoding="application/x-tex">ℂ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord amsrm">C</span></span></span></span>, denoting by <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝒫</mi></mrow><annotation encoding="application/x-tex">𝒫</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7em;"></span><span class="mord mathscr" style="margin-right:0.08078em;">P</span></span></span></span>   the contravariant presheaf endofunctor on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mi>𝐀</mi><mi>𝐓</mi></mrow><annotation encoding="application/x-tex">𝐂𝐀𝐓</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6861em;"></span><span class="mord mathbf">CAT</span></span></span></span>, we have the restriction functor along Yoneda <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝒫</mi><mo stretchy="false">(</mo><msub><mi>𝐲</mi><mi mathvariant="normal">C</mi></msub><mo stretchy="false">)</mo><mo>:</mo><mi>𝒫</mi><mo stretchy="false">(</mo><mi>𝒫</mi><mi mathvariant="normal">C</mi><mo stretchy="false">)</mo><mo>→</mo><mi>𝒫</mi><mi mathvariant="normal">C</mi></mrow><annotation encoding="application/x-tex">𝒫(𝐲_ℂ): 𝒫(𝒫ℂ) → 𝒫ℂ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathscr" style="margin-right:0.08078em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3322em;"><span style="top:-2.55em;margin-left:-0.016em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord amsrm mtight">C</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathscr" style="margin-right:0.08078em;">P</span><span class="mopen">(</span><span class="mord mathscr" style="margin-right:0.08078em;">P</span><span class="mord amsrm">C</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7em;"></span><span class="mord mathscr" style="margin-right:0.08078em;">P</span><span class="mord amsrm">C</span></span></span></span>. Because <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">C</mi></mrow><annotation encoding="application/x-tex">ℂ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord amsrm">C</span></span></span></span> is small and Set is complete, this functor has a right adjoint given by right Kan extension. Now if I'm not mistaken, in this particular case, right Kan extension is given precisely by <br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>𝐲</mi><mrow><mi>𝒫</mi><mi mathvariant="normal">C</mi></mrow></msub><mo>:</mo><mi>𝒫</mi><mi mathvariant="normal">C</mi><mo>→</mo><mi>𝒫</mi><mo stretchy="false">(</mo><mi>𝒫</mi><mi mathvariant="normal">C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">𝐲_{𝒫ℂ}: 𝒫ℂ → 𝒫(𝒫ℂ)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34em;"><span style="top:-2.55em;margin-left:-0.016em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathscr mtight" style="margin-right:0.08078em;">P</span><span class="mord amsrm mtight">C</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7em;"></span><span class="mord mathscr" style="margin-right:0.08078em;">P</span><span class="mord amsrm">C</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathscr" style="margin-right:0.08078em;">P</span><span class="mopen">(</span><span class="mord mathscr" style="margin-right:0.08078em;">P</span><span class="mord amsrm">C</span><span class="mclose">)</span></span></span></span>. Is this right? Is it standard? Also, my tentative proof is not difficult, but it is set-based, hence the question: does this hold in any Yoneda structure (or variants thereof)?</p>



{% endraw %}

<hr><p>Last updated: Nov 25 2022 at 00:48 UTC</p>