---
layout: archive
title: Zulip Chat Archive
permalink: /stream/229136-theory:-category-theory/topic/topic_.22reflective.20stability.22.20of.20categories.html
---

<h2>Stream: <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory:-category-theory/index.html">theory: category theory</a></h2>
<h3>Topic: <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory:-category-theory/topic/topic_.22reflective.20stability.22.20of.20categories.html">"reflective stability" of categories</a></h3>

<hr>

<base href="https://categorytheory.zulipchat.com/">

{% raw %}

<a name="355571095"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/229136-theory%3A%20category%20theory/topic/%22reflective%20stability%22%20of%20categories/near/355571095" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Gurkenglas <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory:-category-theory/topic/topic_.22reflective.20stability.22.20of.20categories.html#355571095">(May 03 2023 at 17:58)</a>:</h4>
<p>Recall that a vector space is an algebra of the free-vector-space monad on <strong>Set</strong>.<br>
Likewise, a category is an identity-on-objects algebra of the free-category monad on <strong>Quiv</strong>.<br>
More impressively: Let a precategory be a category without properties.<br>
For a precategory on a quiver q, the following are equivalent:</p>
<ul>
<li>It's a category.</li>
<li>Given it you can only build (that) one.</li>
<li>Given it and a path, you can only build one arrow that you know to be from its source to its target. (Its composite.)</li>
</ul>
<p>To clarify, here's how to recover that a category C is...<br>
  ...associative: Let's define precategories C_left and C_right: Let p be a path in C. If it hasn't length 3, it composes as in C. If it does have the form (f,g,h), it composes to C(C(f,g),h) in C_left and to C(f,C(g,h)) in C_right. Since we've now built C_left and C_right from C, they are C.<br>
  ...unital: You could use C to conjure arrows from empty paths, then sprinkle them into other paths before you compose. By the property of C, those arrows do nothing.</p>
<p>A functor from C to D is then an object map f plus an f-on-objects map from paths in C to arrows in D given which you can only build that one.</p>
<p>In Haskell terms:</p>
<div class="codehilite"><pre><span></span><code>data Path q where Nil :: Path q s s; Snoc :: Path q s t -&gt; q t u -&gt; Path q s u
type Precategory q = forall s t. Path q s t -&gt; q s t
type Redefinition = forall q. Precategory q -&gt; Precategory q
-- A category is a precategory on which all redefinitions agree. (id in particular.)
rassoc :: Redefinition
rassoc c (Snoc (Snoc (Snoc Nil f) g) h) = c (Snoc (Snoc Nil f) (c (Snoc (Snoc Nil g) h)))
type Prefunctor f q r = forall s t. Path q s t -&gt; r (f s) (f t)
type Redefinition2 = forall f q r. (Precategory q, Precategory r, Prefunctor f q r) -&gt; Prefunctor f q r
-- A functor is a prefunctor between categories on which all redefinition2s agree.
</code></pre></div>
<p>Remark: There is exactly one "forall q. Precategory (Path q)".</p>
<p><a href="http://golem.ph.utexas.edu/category/2012/05/postulated_colimits_and_absolu.html#c041397">Tom Leinster's "possible to even mention" concept</a> is possible to mention here.</p>
<p>Might one characterize the structure of <strong>Quiv</strong> by this property corresponding to unitality and associativity?<br>
The jackpot case would be that this is a compact enough seed for category theory that one can calculate out a grid of all sensible math concepts, making clever definitions obsolete and math tractable.</p>
<p>Anyway. Ideas? Prior work?</p>



{% endraw %}

<hr><p>Last updated: May 04 2023 at 00:09 UTC</p>