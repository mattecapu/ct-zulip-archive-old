---
layout: archive
title: Zulip Chat Archive
permalink: /stream/229136-theory:-category-theory/topic/topic_slice.20functor.20factorization.html
---

<h2>Stream: <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory:-category-theory/index.html">theory: category theory</a></h2>
<h3>Topic: <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory:-category-theory/topic/topic_slice.20functor.20factorization.html">slice functor factorization</a></h3>

<hr>

<base href="https://categorytheory.zulipchat.com/">

{% raw %}

<a name="304103465"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/229136-theory%3A%20category%20theory/topic/slice%20functor%20factorization/near/304103465" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bruno Gavranovic <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory:-category-theory/topic/topic_slice.20functor.20factorization.html#304103465">(Oct 14 2022 at 19:36)</a>:</h4>
<p>It’s known that the covariant slice functor <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">C</mi><mo>→</mo><mrow><mi mathvariant="bold">C</mi><mi mathvariant="bold">a</mi><mi mathvariant="bold">t</mi></mrow></mrow><annotation encoding="application/x-tex">\mathcal{C} \to \mathbf{Cat}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6861em;"></span><span class="mord"><span class="mord mathbf">Cat</span></span></span></span></span> (defined by postcomposition) can be factored through the Yoneda embedding <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>:</mo><mi mathvariant="script">C</mi><mo>→</mo><mo stretchy="false">[</mo><msup><mi mathvariant="script">C</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup><mo separator="true">,</mo><mrow><mi mathvariant="bold">S</mi><mi mathvariant="bold">e</mi><mi mathvariant="bold">t</mi></mrow><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">y : \mathcal{C} \to [\mathcal{C}^{op}, \mathbf{Set}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathcal" style="margin-right:0.05834em;">C</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">p</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathbf">Set</span></span><span class="mclose">]</span></span></span></span> and the category of elements <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi><mo>:</mo><mo stretchy="false">[</mo><msup><mi mathvariant="script">C</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup><mo separator="true">,</mo><mrow><mi mathvariant="bold">S</mi><mi mathvariant="bold">e</mi><mi mathvariant="bold">t</mi></mrow><mo stretchy="false">]</mo><mo>→</mo><mrow><mi mathvariant="bold">C</mi><mi mathvariant="bold">a</mi><mi mathvariant="bold">t</mi></mrow></mrow><annotation encoding="application/x-tex">\Sigma: [\mathcal{C}^{op}, \mathbf{Set}] \to \mathbf{Cat}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Σ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathcal" style="margin-right:0.05834em;">C</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">p</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathbf">Set</span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6861em;"></span><span class="mord"><span class="mord mathbf">Cat</span></span></span></span></span>. Is it known whether there’s an analogous factorization for the contravariant slice construction defined by pullback?</p>



<a name="304637171"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/229136-theory%3A%20category%20theory/topic/slice%20functor%20factorization/near/304637171" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> El Mehdi Cherradi <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory:-category-theory/topic/topic_slice.20functor.20factorization.html#304637171">(Oct 18 2022 at 09:00)</a>:</h4>
<p>Well, any functor to a cocomplete category factors (up to isomorphism) through the Yoneda embedding followed by its left Kan extension along the latter (which is the factorization of your example), but I don't think that is what you are looking for ?</p>



<a name="305092935"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/229136-theory%3A%20category%20theory/topic/slice%20functor%20factorization/near/305092935" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bruno Gavranovic <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory:-category-theory/topic/topic_slice.20functor.20factorization.html#305092935">(Oct 20 2022 at 07:21)</a>:</h4>
<p>I didn't know about that. Do you have a reference/some more elaboration for this? </p>
<p>Trying to understand what you said - If a functor to a cocomplete category <em>factors</em> through a Kan extension along the Yoneda embedding, then it means the natural transformation in the Kan extension isn't <em>just</em> a natural transformation, but an <em>isomorphism</em>, right?</p>



<a name="305103920"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/229136-theory%3A%20category%20theory/topic/slice%20functor%20factorization/near/305103920" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> El Mehdi Cherradi <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory:-category-theory/topic/topic_slice.20functor.20factorization.html#305103920">(Oct 20 2022 at 08:40)</a>:</h4>
<p>This nlab page discusses this particular case : <a href="https://ncatlab.org/nlab/show/free+cocompletion">https://ncatlab.org/nlab/show/free+cocompletion</a> (Proposition 2.1).<br>
It is a very general result that taking a (normal or even homotopy) Kan extension along a fully faithful functor then restricting along the same functor gets you back where you started from up to isomorphism; you can have a look at the Examples section here for instance : <a href="https://ncatlab.org/nlab/show/exact+square#fully_faithful_functors">https://ncatlab.org/nlab/show/exact+square#fully_faithful_functors</a>.</p>



{% endraw %}

<hr><p>Last updated: Oct 22 2022 at 01:11 UTC</p>