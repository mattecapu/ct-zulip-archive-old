---
layout: archive
title: Zulip Chat Archive
permalink: /stream/229136-theory:-category-theory/topic/topic_Every.20double.20category.20is.20a.20double.20colimit.20in.20a.20canonical.20way.html
---

<h2>Stream: <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory:-category-theory/index.html">theory: category theory</a></h2>
<h3>Topic: <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory:-category-theory/topic/topic_Every.20double.20category.20is.20a.20double.20colimit.20in.20a.20canonical.20way.html">Every double category is a double colimit in a canonical way</a></h3>

<hr>

<base href="https://categorytheory.zulipchat.com/">

{% raw %}

<a name="384377701"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/229136-theory%3A%20category%20theory/topic/Every%20double%20category%20is%20a%20double%20colimit%20in%20a%20canonical%20way/near/384377701" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Patrick Nicodemus <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229136-theory:-category-theory/topic/topic_Every.20double.20category.20is.20a.20double.20colimit.20in.20a.20canonical.20way.html#384377701">(Aug 13 2023 at 01:42)</a>:</h4>
<p>We can regard 2-category theory as Cat-enriched category theory. In this setting, if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">C</mi></mrow><annotation encoding="application/x-tex">\mathcal{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span></span></span></span> is a small category, then the weighted colimit of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>:</mo><mn>1</mn><mo>→</mo><mrow><mi mathvariant="bold">C</mi><mi mathvariant="bold">a</mi><mi mathvariant="bold">t</mi></mrow></mrow><annotation encoding="application/x-tex">1 : 1\to \mathbf{Cat}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6861em;"></span><span class="mord"><span class="mord mathbf">Cat</span></span></span></span></span> with weights in the "presheaf" <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">C</mi><mo>:</mo><mn>1</mn><mo>→</mo><mrow><mi mathvariant="bold">C</mi><mi mathvariant="bold">a</mi><mi mathvariant="bold">t</mi></mrow></mrow><annotation encoding="application/x-tex">\mathcal{C} : 1\to \mathbf{Cat}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6861em;"></span><span class="mord"><span class="mord mathbf">Cat</span></span></span></span></span> is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">C</mi></mrow><annotation encoding="application/x-tex">\mathcal{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span></span></span></span> itself. Thus every category can be written in a canonical way as the colimit of the one-object category. (This is well known but I would like a reference for it if anyone can find one)</p>
<p>Anyway, is there anything similar for double categories? Where every double category is in a canonical way a double colimit of the one object double category, the walking vertical arrow, and the walking composition of two vertical morphisms, or something like this. I am studying a functor on double categories which has a 1-categorical right adjoint and so should preserve colimits, and I am looking for an elegant way to state this, that its behavior on any double category is simply determined by gluing together the "primitive" double categories that make it up.</p>



{% endraw %}

<hr><p>Last updated: Aug 13 2023 at 12:08 UTC</p>