---
layout: archive
title: Zulip Chat Archive
permalink: /stream/347879-workshop:-Categories-for-AI/topic/topic_The.20simple.20essence.20of.20automatic.20differentiation.html
---

<h2>Stream: <a href="https://mattecapu.github.io/ct-zulip-archive/stream/347879-workshop:-Categories-for-AI/index.html">workshop: Categories for AI</a></h2>
<h3>Topic: <a href="https://mattecapu.github.io/ct-zulip-archive/stream/347879-workshop:-Categories-for-AI/topic/topic_The.20simple.20essence.20of.20automatic.20differentiation.html">The simple essence of automatic differentiation</a></h3>

<hr>

<base href="https://categorytheory.zulipchat.com/">

{% raw %}

<a name="307007272"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/347879-workshop%3A%20Categories%20for%20AI/topic/The%20simple%20essence%20of%20automatic%20differentiation/near/307007272" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dan Oneață <a href="https://mattecapu.github.io/ct-zulip-archive/stream/347879-workshop:-Categories-for-AI/topic/topic_The.20simple.20essence.20of.20automatic.20differentiation.html#307007272">(Oct 30 2022 at 20:57)</a>:</h4>
<p>Hello! <span aria-label="wave" class="emoji emoji-1f44b" role="img" title="wave">:wave:</span>  I have a question regarding <a href="https://dl.acm.org/doi/pdf/10.1145/3236765">The Simple Essence of Automatic Differentiation</a> by Conal Elliott. While the paper is not part of the course's curriculum, it is quite related to the topics discussed here, so I hope it's not too off-topic to ask here. To give some context, the paper generalizes automatic differentiation such that when instantiated to a given category <code>k</code> it recovers various flavours of automatic differentiation algorithms (<em>e.g.</em>, setting <code>k</code> to <code>Cont</code> yields reverse-mode automatic differentiation).</p>
<p>My question is the following: The paper claims that <code>Cont</code> (Section 12) results in fully left-associative computations, but is that the case for <code>Dual</code> (Section 13) as well? The paper seems to suggest that yes:</p>
<blockquote>
<p>[W]e can turn the <code>Cont</code> and <code>Dual</code> techniques around to yield category transformers that perform full right- instead of left-association.</p>
</blockquote>
<p>But it appears to me that it's not the case, since based on the definition in Figure 10, <code>Dual</code> just reverses the composition of the original computation. For example, if we were given an expression of the form</p>
<div class="codehilite"><pre><span></span><code>(f . g) . ((h . i) . k)
</code></pre></div>
<p>applying the <code>D</code> differentiation functor (corresponding to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><msub><mtext>Dual</mtext><mo lspace="0em" rspace="0em">→</mo></msub></msub></mrow><annotation encoding="application/x-tex">D_{\text{Dual}_{\rightarrow}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9334em;vertical-align:-0.2501em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">Dual</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1191em;"><span style="top:-2.357em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mrel mtight">→</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2501em;"><span></span></span></span></span></span></span></span></span></span> in the paper) we would obtain:</p>
<div class="codehilite"><pre><span></span><code>D ((f . g) . ((h . i) . k))
= { definition of composition: D (f . g) = D g . D f }
(D k . (D i . D h)) . (D g . D f)
</code></pre></div>
<p>which is not left-associative.</p>
<p>What am I missing?</p>



<a name="307208281"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/347879-workshop%3A%20Categories%20for%20AI/topic/The%20simple%20essence%20of%20automatic%20differentiation/near/307208281" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Niklas Schmitz <a href="https://mattecapu.github.io/ct-zulip-archive/stream/347879-workshop:-Categories-for-AI/topic/topic_The.20simple.20essence.20of.20automatic.20differentiation.html#307208281">(Oct 31 2022 at 21:48)</a>:</h4>
<p>Hi there! I also found this paper quite intriguing. I can't say I've understood all details of it so far but perhaps this helps:<br>
In section 12 the third paragraph seems crucial for this and onwards:</p>
<blockquote>
<p>Given any category k, we can represent its morphisms by the intent to left-compose with some to-be-given<br>
morphism h. That is, represent f :: a ‘k‘ b by the function (◦ f ) :: (b ‘k‘ r ) → (a ‘k‘ r ), where r is any object in<br>
k. The morphism h will be a continuation, finishing the journey from f all the way to the codomain of the<br>
overall function being assembled. Building a category around this idea results in converting all composition<br>
patterns into fully left-associated form. This trick is akin to conversion to continuation-passing style [Reynolds,<br>
1972; Appel, 2007; Kennedy, 2007]. [...]</p>
</blockquote>



<a name="307211356"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/347879-workshop%3A%20Categories%20for%20AI/topic/The%20simple%20essence%20of%20automatic%20differentiation/near/307211356" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Niklas Schmitz <a href="https://mattecapu.github.io/ct-zulip-archive/stream/347879-workshop:-Categories-for-AI/topic/topic_The.20simple.20essence.20of.20automatic.20differentiation.html#307211356">(Oct 31 2022 at 22:09)</a>:</h4>
<p>The arxiv version of the paper (<a href="https://arxiv.org/abs/1804.00746">https://arxiv.org/abs/1804.00746</a>) also contains an appendix with proofs &amp; calculations which I found helpful to see the stated specifications and definitions in action, in particular when proving functoriality of <code>cont</code> and <code>asDual</code></p>



<a name="307217537"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/347879-workshop%3A%20Categories%20for%20AI/topic/The%20simple%20essence%20of%20automatic%20differentiation/near/307217537" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dan Oneață <a href="https://mattecapu.github.io/ct-zulip-archive/stream/347879-workshop:-Categories-for-AI/topic/topic_The.20simple.20essence.20of.20automatic.20differentiation.html#307217537">(Oct 31 2022 at 22:55)</a>:</h4>
<p><span class="user-mention silent" data-user-id="553436">Niklas Schmitz</span> <a href="#narrow/stream/347879-workshop.3A-Categories-for-AI/topic/The.20simple.20essence.20of.20automatic.20differentiation/near/307208281">said</a>:</p>
<blockquote>
<p>Hi there! I also found this paper quite intriguing. I can't say I've understood all details of it so far but perhaps this helps:<br>
In section 12 the third paragraph seems crucial for this and onwards:</p>
</blockquote>
<p>Thanks, Niklas! But my confusion is about the left-associativity resulting from <code>Dual</code> (and not that of <code>Cont</code>, which is the subject of Section 12). I understand that</p>
<ul>
<li><code>Cont</code> yields left-associative computations; and that</li>
<li><code>Dual</code> is obtained from <code>Cont</code> by applying the <code>asDual</code> functor,<br>
but it's not obvious to me why <code>asDual</code> preserves left associativity?</li>
</ul>



<a name="307217818"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/347879-workshop%3A%20Categories%20for%20AI/topic/The%20simple%20essence%20of%20automatic%20differentiation/near/307217818" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Dan Oneață <a href="https://mattecapu.github.io/ct-zulip-archive/stream/347879-workshop:-Categories-for-AI/topic/topic_The.20simple.20essence.20of.20automatic.20differentiation.html#307217818">(Oct 31 2022 at 22:57)</a>:</h4>
<p>By the way, regarding terminology, someone can correct me if I'm wrong, but I think that</p>
<ul>
<li><code>Cont^R</code> corresponds to the functor that carries a vector space to its dual, and</li>
<li><code>Dual</code> is the adjoint (or transpose) functor between Hilbert spaces.</li>
</ul>



{% endraw %}

<hr><p>Last updated: Nov 02 2022 at 01:03 UTC</p>