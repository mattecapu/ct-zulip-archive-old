---
layout: archive
title: Zulip Chat Archive
permalink: /stream/229199-learning:-questions/topic/topic_objects.20.E2.80.9Care.E2.80.9D.20something.html
---

<h2>Stream: <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning:-questions/index.html">learning: questions</a></h2>
<h3>Topic: <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning:-questions/topic/topic_objects.20.E2.80.9Care.E2.80.9D.20something.html">objects “are” something</a></h3>

<hr>

<base href="https://categorytheory.zulipchat.com/">

{% raw %}

<a name="383326711"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/229199-learning%3A%20questions/topic/objects%20%E2%80%9Care%E2%80%9D%20something/near/383326711" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Julius <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning:-questions/topic/topic_objects.20.E2.80.9Care.E2.80.9D.20something.html#383326711">(Aug 09 2023 at 15:23)</a>:</h4>
<p>I have been thinking about categories more as abstract objects in their own right, where you do not need to interpret their objects and arrows as some underlying mathematical objects like sets, topologies, etc.</p>
<p>This has made me wonder if it is mathematically rigorous to even say that the objects and arrows of a category “are” anything, other than, abstractly, something called “objects” and “arrows”.</p>
<p>If we say that the arrows are actually group homomorphisms, for example, couldn’t we have some technical apparatus declaring like, a correspondence, first, between objects in group theory, and the abstract elements of a category in category theory, before we go ahead and start to use concepts in category theory to prove, or describe, things in group theory?</p>



<a name="383341148"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/229199-learning%3A%20questions/topic/objects%20%E2%80%9Care%E2%80%9D%20something/near/383341148" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> John Baez <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning:-questions/topic/topic_objects.20.E2.80.9Care.E2.80.9D.20something.html#383341148">(Aug 09 2023 at 16:04)</a>:</h4>
<p>You can prove theorems about abstract categories where you don't say what the objects and morphisms are, but you can also start in some framework (like traditional set theory, or type theory, etc.) and define (say) "groups" and "homomorphisms" between them, and then prove they form a category, and then prove theorems about that category, where you get to use properties of groups and homomorphisms.   Both approaches are extremely common, and they interact nicely.</p>



<a name="383375663"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/229199-learning%3A%20questions/topic/objects%20%E2%80%9Care%E2%80%9D%20something/near/383375663" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Julius <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning:-questions/topic/topic_objects.20.E2.80.9Care.E2.80.9D.20something.html#383375663">(Aug 09 2023 at 17:54)</a>:</h4>
<p>Ok, thanks.<br>
This is sort of interesting, <a href="https://mathoverflow.net/questions/82526/does-there-exist-a-name-for-a-nonassociative-category-without-identities">https://mathoverflow.net/questions/82526/does-there-exist-a-name-for-a-nonassociative-category-without-identities</a> , wondering why associativity is so important, if useful structures only emerge with it present. But here it seems there is a whole theory of non-associative categories.</p>



<a name="383382483"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/229199-learning%3A%20questions/topic/objects%20%E2%80%9Care%E2%80%9D%20something/near/383382483" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Todd Trimble <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning:-questions/topic/topic_objects.20.E2.80.9Care.E2.80.9D.20something.html#383382483">(Aug 09 2023 at 18:20)</a>:</h4>
<p>Well, I don't know that it's such a big theory. I guess about the same size theory as for <a href="https://ncatlab.org/nlab/show/magma">magmas</a>, which are "structures without properties", hence useful for some purposes. </p>
<p>Category theory is much bigger, and associativity and identities really are important. One way (just one way) of thinking about associativity is that it guarantees that hom-functors <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mo>−</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo>−</mo><mo separator="true">,</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\hom(A, -), \hom(-, A)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">hom</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">−</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">hom</span><span class="mopen">(</span><span class="mord">−</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">A</span><span class="mclose">)</span></span></span></span> actually are functors (preserve composition). And associativity together with units are crucial to the proof of the Yoneda lemma, in all of its glory and manifestations. It is to my mind is <em>the</em> most fundamental result of category theory (although it takes time to appreciate why it's so fundamental: it brings together many themes surrounding universal properties and representable functors and adjunctions and so much more).</p>



<a name="383391654"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/229199-learning%3A%20questions/topic/objects%20%E2%80%9Care%E2%80%9D%20something/near/383391654" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> David Egolf <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning:-questions/topic/topic_objects.20.E2.80.9Care.E2.80.9D.20something.html#383391654">(Aug 09 2023 at 18:57)</a>:</h4>
<p>Another perspective regarding whether objects "are "something: <br>
As far as I understand, the data describing an object in a category only has impact on the mathematical structure of that category if it has some impact on what morphisms exist in that category and how they compose. For example, I could define a category where the objects are groups, and the morphisms are all functions between the underlying sets of these groups. This category is a lot like a category where the objects are sets and the morphisms are functions between them. If, however, we require these functions between groups to preserve the group structure (so the functions describe group homomorphisms), then the resulting category becomes very different from the category of sets with functions between them.</p>
<p>I think this perspective is especially relevant when trying to think about how to apply categories. I suspect it's probably good to call an object in some category by some intuitive name relating to an application, and to associate some application-relevant data to that object. However, unless this data has some impact on the morphisms of the category being used to model an application, that application data is not really being reflected in the mathematical structure of the category.</p>



<a name="383392400"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/229199-learning%3A%20questions/topic/objects%20%E2%80%9Care%E2%80%9D%20something/near/383392400" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mike Shulman <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning:-questions/topic/topic_objects.20.E2.80.9Care.E2.80.9D.20something.html#383392400">(Aug 09 2023 at 19:00)</a>:</h4>
<p>There's nothing particularly special about category theory here: <em>all</em> structures in mathematics can be studied either abstractly, where the constituents of the structure have no known internal identity other than their "places" in the structure, or concretely using specific examples where the elements have other identity.  For instance, in an abstract group the elements aren't assumed to "be" anything other than "the elements of the underlying set of the group", but in a concrete group these elements may be numbers, matrices, permutations, etc.</p>



<a name="383431514"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/229199-learning%3A%20questions/topic/objects%20%E2%80%9Care%E2%80%9D%20something/near/383431514" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> John Baez <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning:-questions/topic/topic_objects.20.E2.80.9Care.E2.80.9D.20something.html#383431514">(Aug 09 2023 at 23:01)</a>:</h4>
<p>Yes, organizing transformations of some set, vector space, etc. into a group and saying that the abstract group is what really matters is a distillation which involves a choice of opinion about what "really matters", much as organizing some structured sets and structure-preserving maps into a category and saying the abstract category is what "really matters" - in fact it's a special case.</p>



<a name="383431731"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/229199-learning%3A%20questions/topic/objects%20%E2%80%9Care%E2%80%9D%20something/near/383431731" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> John Baez <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning:-questions/topic/topic_objects.20.E2.80.9Care.E2.80.9D.20something.html#383431731">(Aug 09 2023 at 23:02)</a>:</h4>
<p>Luckily, category theory has ways of recording the concreteness of such situations if we want to: we're not stuck in abstractness.   See <a href="https://ncatlab.org/nlab/show/concrete%20category">[[concrete category]]</a>, for example.</p>



<a name="384084998"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/229199-learning%3A%20questions/topic/objects%20%E2%80%9Care%E2%80%9D%20something/near/384084998" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Julius <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning:-questions/topic/topic_objects.20.E2.80.9Care.E2.80.9D.20something.html#384084998">(Aug 11 2023 at 20:20)</a>:</h4>
<p>Thanks, those are the kinds of perspectives I was hoping to hear. I now have an open-ended beginner’s question kind of related to the above.</p>
<p>I was thinking about how perhaps the defining conditions on a functor could be deduced just by the notion that it is supposed to be a “morphism between categories”. But then I asked myself, what properties would I like functors to fulfill, such that their defining conditions (ie, preserving identities, and composition of arrows), manifest those properties?</p>
<p>I have been thinking about how ultimately, the arrows in a category don’t need to “act” on the objects in any way, they can be meaningless token objects which are simply defined as having one object as a domain and one object for a codomain. So, I think we could define a meaningless “category of categories” where the objects are categories but the arrows are not normal functors, they are just, I don’t know, assignments of objects, with no special conditions on the arrows.</p>
<p>So, how might we realize why we would want the definition of a functor to be what it is, if we were trying to define a “category of categories”? <em>Why</em> do we want composition of arrows preserved, by the morphisms? </p>
<p>Thank you</p>



<a name="384085552"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/229199-learning%3A%20questions/topic/objects%20%E2%80%9Care%E2%80%9D%20something/near/384085552" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Julius <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning:-questions/topic/topic_objects.20.E2.80.9Care.E2.80.9D.20something.html#384085552">(Aug 11 2023 at 20:23)</a>:</h4>
<p>I think part of the answer was already given in this:</p>
<blockquote>
<p>One way (just one way) of thinking about associativity is that it guarantees that hom-functors <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mo>−</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo>−</mo><mo separator="true">,</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\hom(A, -), \hom(-, A)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">hom</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">−</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">hom</span><span class="mopen">(</span><span class="mord">−</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">A</span><span class="mclose">)</span></span></span></span> actually are functors (preserve composition). And associativity together with units are crucial to the proof of the Yoneda lemma</p>
</blockquote>
<p>But I need to think about it some more.</p>



<a name="384085956"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/229199-learning%3A%20questions/topic/objects%20%E2%80%9Care%E2%80%9D%20something/near/384085956" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Kevin Arlin <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning:-questions/topic/topic_objects.20.E2.80.9Care.E2.80.9D.20something.html#384085956">(Aug 11 2023 at 20:25)</a>:</h4>
<p>There’s nothing forcing you to want composition of arrows to be preserved. But there’s a long history in abstract algebra of focusing on homomorphisms, ie the maps that preserve every operation present in your theory. A functor is the immediate notion of homomorphism for categories in this sense. Furthermore, a mapping on objects and morphisms respecting source and target but not necessarily composition is just a homomorphism of the underlying graphs, which makes it unnatural to claim you’re describing a category of <em>categories</em> at all.</p>



<a name="384096063"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/229199-learning%3A%20questions/topic/objects%20%E2%80%9Care%E2%80%9D%20something/near/384096063" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mike Shulman <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning:-questions/topic/topic_objects.20.E2.80.9Care.E2.80.9D.20something.html#384096063">(Aug 11 2023 at 21:23)</a>:</h4>
<p>Right, you can define a category by taking the objects to be anything you want and the morphisms to be anything you want.  You could define a category whose objects are groups and whose morphisms are functions between the underlying sets of groups, not necessarily respecting the group operations.  And similarly when the objects are categories.</p>



<a name="384096227"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/229199-learning%3A%20questions/topic/objects%20%E2%80%9Care%E2%80%9D%20something/near/384096227" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mike Shulman <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning:-questions/topic/topic_objects.20.E2.80.9Care.E2.80.9D.20something.html#384096227">(Aug 11 2023 at 21:24)</a>:</h4>
<p>That said, there are precise senses in which functors are the "canonical" morphisms between categories.  For instance, there is an <a href="https://ncatlab.org/nlab/show/essentially%20algebraic%20theory">[[essentially algebraic theory]]</a> whose models are categories, and whose homomorphisms of models are functors.</p>



<a name="384096281"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/229199-learning%3A%20questions/topic/objects%20%E2%80%9Care%E2%80%9D%20something/near/384096281" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mike Shulman <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning:-questions/topic/topic_objects.20.E2.80.9Care.E2.80.9D.20something.html#384096281">(Aug 11 2023 at 21:24)</a>:</h4>
<p>Just as there is an <a href="https://ncatlab.org/nlab/show/algebraic%20theory">[[algebraic theory]]</a> whose models are groups, and whose homomorphisms are group homomorphisms.</p>



<a name="384100294"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/229199-learning%3A%20questions/topic/objects%20%E2%80%9Care%E2%80%9D%20something/near/384100294" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> David Egolf <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning:-questions/topic/topic_objects.20.E2.80.9Care.E2.80.9D.20something.html#384100294">(Aug 11 2023 at 21:54)</a>:</h4>
<p>I find it helpful to think of functors as "sending true equations to true equations":</p>
<ul>
<li>If <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>=</mo><mi>g</mi><mo>∘</mo><mi>h</mi></mrow><annotation encoding="application/x-tex">f = g \circ h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∘</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span></span></span></span> is true in some category <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span>, then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo>=</mo><mi>F</mi><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">)</mo><mo>∘</mo><mi>F</mi><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(f) = F(g) \circ F(h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∘</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mclose">)</span></span></span></span> is true as well, where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> is a functor <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>:</mo><mi>C</mi><mo>→</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">F: C \to D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span>.</li>
<li>Let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span> be a function that takes in a morphism and returns its source object. Then if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">s(f) = x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>, it is true that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo stretchy="false">(</mo><mi>F</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>F</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">s(F(f)) = F(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">))</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>. Similarly, if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span> is a function that takes in a morphism and returns its target object, and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo>=</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">t(f) = y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>, then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo stretchy="false">(</mo><mi>F</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>F</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">t(F(f)) = F(y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">))</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>.</li>
<li>Finally, let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span></span></span></span> be a function that takes in an object and returns its identity morphism. Then if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mn>1</mn><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">e(x) = 1_x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7944em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> we have <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo stretchy="false">(</mo><mi>F</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>F</mi><mo stretchy="false">(</mo><msub><mn>1</mn><mi>x</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">e(F(x)) = F(1_x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">))</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>.</li>
</ul>
<p>From this perspective, if you have a functor <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>:</mo><mi>C</mi><mo>→</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">F: C \to D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span>, and you know some true equations in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span>, then you can use the functor to get true equations in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span>. So, functors can be used as a tool to take things that we know in one category, and figure out new (but related) things in a different category.</p>
<p>Broadly, in any category, I believe we want the internal structure of our objects to have an impact on which morphisms exist and how they compose. So, in a category of categories, we want the morphisms to be closely linked to the internal structure of the categories they are mapping between.</p>



<a name="384117946"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/229199-learning%3A%20questions/topic/objects%20%E2%80%9Care%E2%80%9D%20something/near/384117946" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mike Shulman <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning:-questions/topic/topic_objects.20.E2.80.9Care.E2.80.9D.20something.html#384117946">(Aug 12 2023 at 00:25)</a>:</h4>
<p>There's a geometric / higher categorical interpretation of that too.  You can think of a category as a certain kind of 2-dimensional "cell complex" with vertices being objects, edges being morphisms, and 2-dimensional faces being commutative polygons.  Then a functor is just a "cellular map" that takes vertices to vertices, edges to edges, and faces to faces, the last being a geometric version of "sending true equations to true equations".</p>



{% endraw %}

<hr><p>Last updated: Aug 20 2023 at 12:09 UTC</p>