---
layout: archive
title: Zulip Chat Archive
permalink: /stream/229199-learning:-questions/topic/topic_colimits.20and.20connected.20components.html
---

<h2>Stream: <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning:-questions/index.html">learning: questions</a></h2>
<h3>Topic: <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning:-questions/topic/topic_colimits.20and.20connected.20components.html">colimits and connected components</a></h3>

<hr>

<base href="https://categorytheory.zulipchat.com/">

{% raw %}

<a name="293755819"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/229199-learning%3A%20questions/topic/colimits%20and%20connected%20components/near/293755819" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bruno Gavranovic <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning:-questions/topic/topic_colimits.20and.20connected.20components.html#293755819">(Aug 16 2022 at 16:38)</a>:</h4>
<p>Thanks <span class="user-mention" data-user-id="275989">@Paolo Perrone</span>. During reading of your paper my question slowly crystalized.</p>
<p>Basically, I've noticed a pattern. I noticed people gave a name to the colimit of a particular functor  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>:</mo><mi mathvariant="script">C</mi><mo>→</mo><mrow><mi mathvariant="bold">S</mi><mi mathvariant="bold">e</mi><mi mathvariant="bold">t</mi></mrow></mrow><annotation encoding="application/x-tex">F : \mathcal C \to \mathbf{Set}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6861em;"></span><span class="mord"><span class="mord mathbf">Set</span></span></span></span></span>, and used it in various contexts. But then I noticed this colimit tends to clump a lot of things together - things I want to keep track of separately. I've learned that I can add more fidelity to this construction by not computing the colimit, but instead doing the (op)lax version thereof, after suitably postcomposing with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="sans-serif">discr</mtext><mo>:</mo><mrow><mi mathvariant="bold">S</mi><mi mathvariant="bold">e</mi><mi mathvariant="bold">t</mi></mrow><mo>→</mo><mrow><mi mathvariant="bold">C</mi><mi mathvariant="bold">a</mi><mi mathvariant="bold">t</mi></mrow></mrow><annotation encoding="application/x-tex">\textsf{discr} : \mathbf{Set} \to \mathbf{Cat}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord text"><span class="mord textsf">discr</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6861em;"></span><span class="mord"><span class="mord mathbf">Set</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6861em;"></span><span class="mord"><span class="mord mathbf">Cat</span></span></span></span></span>.</p>
<p>My question is: this this a general recipe? Whenever I have a set, obtained in some universal way, but I want to <em>not</em> quotient things out, is the right way to compute the (op)lax version of that universal construction?</p>
<p>I suppose I'm learning a (in hindsight perhaps obvious) fact that given any universal construction in any context, somebody might be interested in a refinement of that construction by adding higher cells- and really, there's a straightforward way to refine it. It's by realizing that this construction is the result of applying the connected components functor to its refinement.</p>



<a name="293757425"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/229199-learning%3A%20questions/topic/colimits%20and%20connected%20components/near/293757425" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bruno Gavranovic <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning:-questions/topic/topic_colimits.20and.20connected.20components.html#293757425">(Aug 16 2022 at 16:43)</a>:</h4>
<p>I'm actually not sure how clear this is. Maybe I'm just realising that all the higher-category theory is sort of always there, and that there's a canonical way to refine constructions using the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mn>0</mn></msub><mo>⊣</mo><mtext mathvariant="sans-serif">discr</mtext></mrow><annotation encoding="application/x-tex">\pi_0 \dashv \textsf{discr}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊣</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord text"><span class="mord textsf">discr</span></span></span></span></span> adjunction.</p>



<a name="293757524"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/229199-learning%3A%20questions/topic/colimits%20and%20connected%20components/near/293757524" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bruno Gavranovic <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning:-questions/topic/topic_colimits.20and.20connected.20components.html#293757524">(Aug 16 2022 at 16:44)</a>:</h4>
<p>This works at least for colimits, but I'm expecting it holds in more generality.</p>



<a name="293785663"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/229199-learning%3A%20questions/topic/colimits%20and%20connected%20components/near/293785663" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Paolo Perrone <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning:-questions/topic/topic_colimits.20and.20connected.20components.html#293785663">(Aug 16 2022 at 19:29)</a>:</h4>
<p>Yes, this idea seems correct. A lot of times traditional quotients "identify too much", and one loses track of some important information. I think the first people to realize this were algebraic topologists, who came up with the notion of <a href="https://ncatlab.org/nlab/show/homotopy+quotient">homotopy quotient</a> precisely for that purpose. <br>
In general, one can have different formalizations of the same idea, which is "replacing identifications with arrows of some kind".<br>
Other examples of the same idea, where the arrows are "invertible" (more like a pseudo colimit than lax) are the <a href="https://ncatlab.org/nlab/show/action+groupoid">action groupoid</a>, the idea of <a href="https://ncatlab.org/nlab/show/homological+resolution">resolution</a>, and <a href="https://ncatlab.org/nlab/show/fibrant+replacement">cofibrant replacements</a>.  <br>
By the way, this came up recently also in the work of Sean and me on Markov categories and dynamical systems (<a href="https://arxiv.org/abs/2207.07353">see the appendix here</a>).</p>



<a name="293872142"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/229199-learning%3A%20questions/topic/colimits%20and%20connected%20components/near/293872142" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Bruno Gavranovic <a href="https://mattecapu.github.io/ct-zulip-archive/stream/229199-learning:-questions/topic/topic_colimits.20and.20connected.20components.html#293872142">(Aug 17 2022 at 10:42)</a>:</h4>
<p>Ah, amazing. That's great to hear -- that it's not uncommon to try to add more fidelity to universal constructions in this way.</p>



{% endraw %}

<hr><p>Last updated: Jan 29 2023 at 00:51 UTC</p>