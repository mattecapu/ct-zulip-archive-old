---
layout: archive
title: Zulip Chat Archive
permalink: /stream/269484-seminar:-Topos-Colloquium/topic/topic_xtdoor.html
---

<h2>Stream: <a href="https://mattecapu.github.io/ct-zulip-archive/stream/269484-seminar:-Topos-Colloquium/index.html">seminar: Topos Colloquium</a></h2>
<h3>Topic: <a href="https://mattecapu.github.io/ct-zulip-archive/stream/269484-seminar:-Topos-Colloquium/topic/topic_xtdoor.html">xtdoor</a></h3>

<hr>

<base href="https://categorytheory.zulipchat.com/">

{% raw %}

<a name="253103578"></a>
<h4><a href="https://categorytheory.zulipchat.com/#narrow/stream/269484-seminar%3A%20Topos%20Colloquium/topic/xtdoor/near/253103578" class="zl"><img src="https://mattecapu.github.io/ct-zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mike Shulman <a href="https://mattecapu.github.io/ct-zulip-archive/stream/269484-seminar:-Topos-Colloquium/topic/topic_xtdoor.html#253103578">(Sep 13 2021 at 14:56)</a>:</h4>
<p>Thanks <span class="user-mention" data-user-id="438119">@Florian Rabe</span>.  Are your logical frameworks sufficiently expressive to encode the normalization algorithm of object-languages without needing to descend to Scala code again?  How does that work?  Most logical frameworks I've seen can encode the equality judgment of object-languages, or perhaps some small- or big-step operational semantics relation, but I never thought of being able to extract an actual implementation of a normalization algorithm from such an encoding without additional coding.</p>



{% endraw %}

<hr><p>Last updated: Aug 19 2023 at 12:09 UTC</p>