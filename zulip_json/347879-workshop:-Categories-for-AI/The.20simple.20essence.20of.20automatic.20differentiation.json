[
    {
        "content": "<p>Hello! <span aria-label=\"wave\" class=\"emoji emoji-1f44b\" role=\"img\" title=\"wave\">:wave:</span>  I have a question regarding <a href=\"https://dl.acm.org/doi/pdf/10.1145/3236765\">The Simple Essence of Automatic Differentiation</a> by Conal Elliott. While the paper is not part of the course's curriculum, it is quite related to the topics discussed here, so I hope it's not too off-topic to ask here. To give some context, the paper generalizes automatic differentiation such that when instantiated to a given category <code>k</code> it recovers various flavours of automatic differentiation algorithms (<em>e.g.</em>, setting <code>k</code> to <code>Cont</code> yields reverse-mode automatic differentiation).</p>\n<p>My question is the following: The paper claims that <code>Cont</code> (Section 12) results in fully left-associative computations, but is that the case for <code>Dual</code> (Section 13) as well? The paper seems to suggest that yes:</p>\n<blockquote>\n<p>[W]e can turn the <code>Cont</code> and <code>Dual</code> techniques around to yield category transformers that perform full right- instead of left-association.</p>\n</blockquote>\n<p>But it appears to me that it's not the case, since based on the definition in Figure 10, <code>Dual</code> just reverses the composition of the original computation. For example, if we were given an expression of the form</p>\n<div class=\"codehilite\"><pre><span></span><code>(f . g) . ((h . i) . k)\n</code></pre></div>\n<p>applying the <code>D</code> differentiation functor (corresponding to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>D</mi><msub><mtext>Dual</mtext><mo lspace=\"0em\" rspace=\"0em\">→</mo></msub></msub></mrow><annotation encoding=\"application/x-tex\">D_{\\text{Dual}_{\\rightarrow}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9334em;vertical-align:-0.2501em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord text mtight\"><span class=\"mord mtight\">Dual</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1191em;\"><span style=\"top:-2.357em;margin-right:0.0714em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\"><span class=\"mrel mtight\">→</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2501em;\"><span></span></span></span></span></span></span></span></span></span> in the paper) we would obtain:</p>\n<div class=\"codehilite\"><pre><span></span><code>D ((f . g) . ((h . i) . k))\n= { definition of composition: D (f . g) = D g . D f }\n(D k . (D i . D h)) . (D g . D f)\n</code></pre></div>\n<p>which is not left-associative.</p>\n<p>What am I missing?</p>",
        "id": 307007272,
        "sender_full_name": "Dan Oneață",
        "timestamp": 1667163469
    },
    {
        "content": "<p>Hi there! I also found this paper quite intriguing. I can't say I've understood all details of it so far but perhaps this helps:<br>\nIn section 12 the third paragraph seems crucial for this and onwards:</p>\n<blockquote>\n<p>Given any category k, we can represent its morphisms by the intent to left-compose with some to-be-given<br>\nmorphism h. That is, represent f :: a ‘k‘ b by the function (◦ f ) :: (b ‘k‘ r ) → (a ‘k‘ r ), where r is any object in<br>\nk. The morphism h will be a continuation, finishing the journey from f all the way to the codomain of the<br>\noverall function being assembled. Building a category around this idea results in converting all composition<br>\npatterns into fully left-associated form. This trick is akin to conversion to continuation-passing style [Reynolds,<br>\n1972; Appel, 2007; Kennedy, 2007]. [...]</p>\n</blockquote>",
        "id": 307208281,
        "sender_full_name": "Niklas Schmitz",
        "timestamp": 1667252896
    },
    {
        "content": "<p>The arxiv version of the paper (<a href=\"https://arxiv.org/abs/1804.00746\">https://arxiv.org/abs/1804.00746</a>) also contains an appendix with proofs &amp; calculations which I found helpful to see the stated specifications and definitions in action, in particular when proving functoriality of <code>cont</code> and <code>asDual</code></p>",
        "id": 307211356,
        "sender_full_name": "Niklas Schmitz",
        "timestamp": 1667254181
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"553436\">Niklas Schmitz</span> <a href=\"#narrow/stream/347879-workshop.3A-Categories-for-AI/topic/The.20simple.20essence.20of.20automatic.20differentiation/near/307208281\">said</a>:</p>\n<blockquote>\n<p>Hi there! I also found this paper quite intriguing. I can't say I've understood all details of it so far but perhaps this helps:<br>\nIn section 12 the third paragraph seems crucial for this and onwards:</p>\n</blockquote>\n<p>Thanks, Niklas! But my confusion is about the left-associativity resulting from <code>Dual</code> (and not that of <code>Cont</code>, which is the subject of Section 12). I understand that</p>\n<ul>\n<li><code>Cont</code> yields left-associative computations; and that</li>\n<li><code>Dual</code> is obtained from <code>Cont</code> by applying the <code>asDual</code> functor,<br>\nbut it's not obvious to me why <code>asDual</code> preserves left associativity?</li>\n</ul>",
        "id": 307217537,
        "sender_full_name": "Dan Oneață",
        "timestamp": 1667256934
    },
    {
        "content": "<p>By the way, regarding terminology, someone can correct me if I'm wrong, but I think that</p>\n<ul>\n<li><code>Cont^R</code> corresponds to the functor that carries a vector space to its dual, and</li>\n<li><code>Dual</code> is the adjoint (or transpose) functor between Hilbert spaces.</li>\n</ul>",
        "id": 307217818,
        "sender_full_name": "Dan Oneață",
        "timestamp": 1667257041
    }
]