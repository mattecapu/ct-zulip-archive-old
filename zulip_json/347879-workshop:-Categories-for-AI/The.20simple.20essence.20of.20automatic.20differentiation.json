[
    {
        "content": "<p>Hello! <span aria-label=\"wave\" class=\"emoji emoji-1f44b\" role=\"img\" title=\"wave\">:wave:</span>  I have a question regarding <a href=\"https://dl.acm.org/doi/pdf/10.1145/3236765\">The Simple Essence of Automatic Differentiation</a> by Conal Elliott. While the paper is not part of the course's curriculum, it is quite related to the topics discussed here, so I hope it's not too off-topic to ask here. To give some context, the paper generalizes automatic differentiation such that when instantiated to a given category <code>k</code> it recovers various flavours of automatic differentiation algorithms (<em>e.g.</em>, setting <code>k</code> to <code>Cont</code> yields reverse-mode automatic differentiation).</p>\n<p>My question is the following: The paper claims that <code>Cont</code> (Section 12) results in fully left-associative computations, but is that the case for <code>Dual</code> (Section 13) as well? The paper seems to suggest that yes:</p>\n<blockquote>\n<p>[W]e can turn the <code>Cont</code> and <code>Dual</code> techniques around to yield category transformers that perform full right- instead of left-association.</p>\n</blockquote>\n<p>But it appears to me that it's not the case, since based on the definition in Figure 10, <code>Dual</code> just reverses the composition of the original computation. For example, if we were given an expression of the form</p>\n<div class=\"codehilite\"><pre><span></span><code>(f . g) . ((h . i) . k)\n</code></pre></div>\n<p>applying the <code>D</code> differentiation functor (corresponding to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>D</mi><msub><mtext>Dual</mtext><mo lspace=\"0em\" rspace=\"0em\">→</mo></msub></msub></mrow><annotation encoding=\"application/x-tex\">D_{\\text{Dual}_{\\rightarrow}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9334em;vertical-align:-0.2501em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord text mtight\"><span class=\"mord mtight\">Dual</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1191em;\"><span style=\"top:-2.357em;margin-right:0.0714em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\"><span class=\"mrel mtight\">→</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2501em;\"><span></span></span></span></span></span></span></span></span></span> in the paper) we would obtain:</p>\n<div class=\"codehilite\"><pre><span></span><code>D ((f . g) . ((h . i) . k))\n= { definition of composition: D (f . g) = D g . D f }\n(D k . (D i . D h)) . (D g . D f)\n</code></pre></div>\n<p>which is not left-associative.</p>\n<p>What am I missing?</p>",
        "id": 307007272,
        "sender_full_name": "Dan Oneață",
        "timestamp": 1667163469
    }
]