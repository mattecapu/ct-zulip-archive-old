[
    {
        "content": "<p>Recently I have started studying sequent calculus. The original proof of the cut-elimination theorem by Gentzen looks very complex. I was wondering if there is some very easy proof of cut-elimination (may be non-constructive) which is also applicable to a wide variety of other sequent systems.  Here by the <strong>cut-rule</strong> I mean the following: if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mo>⊢</mo><mi mathvariant=\"bold\">S</mi></msub><mi mathvariant=\"normal\">Γ</mi><mo>⇒</mo><mi mathvariant=\"normal\">Δ</mi><mo separator=\"true\">,</mo><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">\\vdash_{\\mathbf{S}}\\Gamma\\Rightarrow \\Delta,\\alpha</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mrel\"><span class=\"mrel\">⊢</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3303em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathbf mtight\">S</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">Γ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⇒</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord\">Δ</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mo>⊢</mo><mi mathvariant=\"bold\">S</mi></msub><mi>α</mi><mo separator=\"true\">,</mo><mi mathvariant=\"normal\">Γ</mi><mo>⇒</mo><mi mathvariant=\"normal\">Δ</mi></mrow><annotation encoding=\"application/x-tex\">\\vdash_{\\mathbf{S}}\\alpha,\\Gamma\\Rightarrow\\Delta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mrel\"><span class=\"mrel\">⊢</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3303em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathbf mtight\">S</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">Γ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⇒</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">Δ</span></span></span></span> then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mo>⊢</mo><mi mathvariant=\"bold\">S</mi></msub><mi mathvariant=\"normal\">Γ</mi><mo>⇒</mo><mi mathvariant=\"normal\">Δ</mi></mrow><annotation encoding=\"application/x-tex\">\\vdash_{\\mathbf{S}}\\Gamma\\Rightarrow\\Delta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mrel\"><span class=\"mrel\">⊢</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3303em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathbf mtight\">S</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">Γ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⇒</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">Δ</span></span></span></span> where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mo>⊢</mo><mi mathvariant=\"bold\">S</mi></msub><mi mathvariant=\"normal\">Γ</mi><mo>⇒</mo><mi mathvariant=\"normal\">Δ</mi></mrow><annotation encoding=\"application/x-tex\">\\vdash_{\\mathbf{S}}\\Gamma\\Rightarrow\\Delta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mrel\"><span class=\"mrel\">⊢</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3303em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathbf mtight\">S</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">Γ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⇒</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">Δ</span></span></span></span> means that there is a proof of the sequent <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Γ</mi><mo>⇒</mo><mi mathvariant=\"normal\">Δ</mi></mrow><annotation encoding=\"application/x-tex\">\\Gamma\\Rightarrow\\Delta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">Γ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⇒</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">Δ</span></span></span></span> in the sequent system <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"bold\">S</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbf{S}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6861em;\"></span><span class=\"mord mathbf\">S</span></span></span></span>.</p>",
        "id": 303266209,
        "sender_full_name": "সায়ন্তন রায়",
        "timestamp": 1665410599
    },
    {
        "content": "<p>My impression is that the cut-elimination theorem is a deep result (because it is supposed to be an argument for the consistency of logic) and also delicate (i.e. sensitive to hypotheses), and my experience is that such theorems do not have \"easy\" proofs.</p>",
        "id": 303268421,
        "sender_full_name": "Zhen Lin Low",
        "timestamp": 1665411371
    },
    {
        "content": "<p>That's my impression too, but I've never gone through this proof, so I'd like to hear people's opinions on what's the easiest proof to follow.    (Of course what's easy to follow depends on the person.   If you know me, you can guess what I find easy to follow.)</p>",
        "id": 303270841,
        "sender_full_name": "John Baez",
        "timestamp": 1665412207
    },
    {
        "content": "<p>Actually, I am more interested to see \"easy\" proofs of cut-elimination theorem for the sequent systems of propositional logics.</p>",
        "id": 303272392,
        "sender_full_name": "সায়ন্তন রায়",
        "timestamp": 1665412742
    },
    {
        "content": "<p>The proof of cut-elimination for classic logic is complex because classical logic is a system about truth values which is quite abstract. I know more the one for linear logic.</p>\n<p>The cut-elimination for linear logic is much more down to earth. It is really algorithmic: you have a transformation to use for each instance of the cut rule and this transformation depends of the two inference rules used before the cut rule. It gives you an algorithm with a very good property: you can apply these transformations in any order, at the end you will have a proof without any cut. The proof thus consists in:<br>\n1) List the transformation to apply to a cut depending on the two preceding used inference rules.<br>\n2) Define a measure which attributes a nonnegative integer to every proof (typically something like the sum of the depths of all cuts in the proof).<br>\n3) Prove that the measure decreases strictly when you apply a transformation.<br>\nBecause the measure can't be negative, you know that you can eliminate the cuts, moreover with the good property.</p>\n<p>Classical logic is not about algorithms but more about the truth. Proving the cut elimination is thus more about proving that the theorem is true but without any concrete algorithm. However some people know probably more about this than me and you should also have some more or less algorithmic interpretation of the cut elimination for classical logic but it's more complicated.</p>",
        "id": 303330806,
        "sender_full_name": "Jean-Baptiste Vienney",
        "timestamp": 1665439440
    },
    {
        "content": "<p>You can get cheap &amp; easy proofs of cut-elimination by completeness of the cut-free calculus. But the interest in cut-elimination results often lie in the precise bounds associated with more refined versions (e.g., ordinal indexed versions).</p>",
        "id": 303372589,
        "sender_full_name": "Ulrik Buchholtz",
        "timestamp": 1665473102
    },
    {
        "content": "<p>How do you prove completeness of the cut-free calculus without basically proving cut-elimination?</p>",
        "id": 303381305,
        "sender_full_name": "Mike Shulman",
        "timestamp": 1665476912
    },
    {
        "content": "<p>I'm interested as well by the answer <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 303381783,
        "sender_full_name": "Jean-Baptiste Vienney",
        "timestamp": 1665477137
    },
    {
        "content": "<p>Actually, cut-elimination in classical logic is provable by exactly the same methods mentioned by <span class=\"user-mention\" data-user-id=\"428716\">@Jean-Baptiste Vienney</span>.  See for instance Chapter 13 of Girard, Lafont and Taylor's <em><a href=\"https://www.paultaylor.eu/stable/prot.pdf\">Proofs and Types</a></em>. In fact, cut-elimination in linear logic is just a re-iteration of the usual proof for classical sequent calculus, which is very modular and applies essentially unchanged to lots of different systems (it only relies on the existence of rewriting rules for so-called <em>principal cuts</em> and the fact that a non-principal cut may be turned into a principal one via some commutations).</p>\n<p>The non-constructiveness of classical logic does not manifest itself in the absence of an algorithmic procedure for eliminating cuts, but rather in the uncontrolled non-determinism of such a procedure: a single proof with cuts may reduce to a host of cut-free proofs (of the same sequent).  If one wants to see proofs as programs, this is a deal-breaker because it means that programs do not have a well-defined result.  By contrast, the very same procedure in intuitionistic logic is deterministic: modulo inessential commutations, every proof reduces to a unique cut-free proof.  Classical sequent calculi with a deterministic cut-elimination procedure do exist, but they all require some notion of polarity which was understood only after the introduction of linear logic (so more than half a century after Gentzen).</p>",
        "id": 303410004,
        "sender_full_name": "Damiano Mazza",
        "timestamp": 1665488979
    },
    {
        "content": "<p>About the \"difficulty\" of the cut-elimination proof, of course it depends on the eye of the beholder but I do not find the usual proof to be particularly hard.  Like many syntactic theorems, there's just a ton of cases to inspect, but there's nothing difficult conceptually: you assign an ordinal to every proof (for \"pure\" first order logic it will be smaller than <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>ω</mi><mi>ω</mi></msup></mrow><annotation encoding=\"application/x-tex\">\\omega^\\omega</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6644em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ω</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">ω</span></span></span></span></span></span></span></span></span></span></span>, so nothing scary at all), such that cut-free proofs have ordinal <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span>, and then show that in every proof <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>π</mi></mrow><annotation encoding=\"application/x-tex\">\\pi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">π</span></span></span></span> with cuts there's always a cut which may be rewritten so that the ordinal of the resulting proof is strictly smaller than the ordinal of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>π</mi></mrow><annotation encoding=\"application/x-tex\">\\pi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">π</span></span></span></span>.  Such a cut is usually immediate to find (it is one such that there are no other cuts above it, which exists by finiteness of proofs).</p>\n<p>The number of cases heavily depends on the specific formulation of sequent calculus.  For classical first-order logic, one may use a one-sided formulation, which drastically reduces the number of cases.  This is the approach I take when I teach this stuff.  For example, in Chapter 6 of <a href=\"https://lipn.univ-paris13.fr/~mazza/teaching/ProofTheoryNotes.pdf\">these notes</a> I manage to do it with only four principal cases and two commutative cases.</p>\n<p>NB: All the above assumes that we are talking about propositional or first-order logic.  Cut-elimination for higher-order logic is another story: for example, cut-elimination of second-order intuitionistic sequent calculus implies the consistency of second-order Peano arithmetic, which is huge.  You need non-trivial techniques for that, essentially boiling down to Girard's <em>reducibility candidates</em>.  I guess it is fair to say that <em>those</em> proofs are hard <span aria-label=\"big smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"big smile\">:big_smile:</span></p>",
        "id": 303422300,
        "sender_full_name": "Damiano Mazza",
        "timestamp": 1665489796
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276839\">Damiano Mazza</span> <a href=\"#narrow/stream/233104-theory.3A-logic/topic/proofs.20of.20cut-elimination.20theorem/near/303410004\">said</a>:</p>\n<blockquote>\n<p>By contrast, the very same procedure in intuitionistic logic is deterministic: modulo inessential commutations, every proof reduces to a unique cut-free proof.</p>\n</blockquote>\n<p>Indeed, but I'd add that even in intuitionistic logic, it is useful to distinguish between the proof-irrelevant \"cut-admissibility\" and the proof-relevant \"normalization\", as discussed here: <a href=\"https://prooftheory.blog/2020/09/07/simple-proofs-of-cut-elimination-ii-intuitionistic-logic/\">https://prooftheory.blog/2020/09/07/simple-proofs-of-cut-elimination-ii-intuitionistic-logic/</a></p>",
        "id": 303473725,
        "sender_full_name": "Lê Thành Dũng (Tito) Nguyễn",
        "timestamp": 1665505396
    },
    {
        "content": "<p>BTW cut-elimination for classical logic is discussed in the same blog post series here: <a href=\"https://prooftheory.blog/2020/05/07/simpler-proofs-of-cut-elimination-i-classical-logic/\">https://prooftheory.blog/2020/05/07/simpler-proofs-of-cut-elimination-i-classical-logic/</a></p>",
        "id": 303473948,
        "sender_full_name": "Lê Thành Dũng (Tito) Nguyễn",
        "timestamp": 1665505457
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276777\">Mike Shulman</span> <a href=\"#narrow/stream/233104-theory.3A-logic/topic/proofs.20of.20cut-elimination.20theorem/near/303381305\">said</a>:</p>\n<blockquote>\n<p>How do you prove completeness of the cut-free calculus without basically proving cut-elimination?</p>\n</blockquote>\n<p>(also to <span class=\"user-mention\" data-user-id=\"428716\">@Jean-Baptiste Vienney</span>) One way is via Schütte's search tree method. You define a canonically defined, potentially infinite, proof tree, that systematically uses all rules (and is “fair” in some sense). If this tree is finite, it gives a proof, and the key is to show that if it's infinite, you can build a countermodel (so this is a classical argument).</p>\n<p>This has a quite different feel to it than a direct cut-elimination proof, no?</p>",
        "id": 303512806,
        "sender_full_name": "Ulrik Buchholtz",
        "timestamp": 1665519345
    }
]