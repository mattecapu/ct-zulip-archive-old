[
    {
        "content": "<p>As much as I love the category, I'm noticing how bizarrely frustrating it is to write a mode-dependent dynamical systems (a reservoir computer in my case) using Poly constructs. When it comes to generating actual numbers for something nontrivial, debugging becomes a nightmare. It takes several minutes to do the plumbing necessary just to get the outer system to output information I can actually analyze.</p>\n<p>Something obvious only happened to occurr to me this week: there's nothing Poly can do that Set can't, really. A dynamical system is just a morphism? Great, it actually is just a morphism in Set also (albeit one that is a giant composition of functions). If you care about type safety, just write Haskell code and use Debug.trace when developing something.</p>\n<p>I'm asking this with love of course. I've been excited about the category and have loved working with it, but debugging it versus debugging a little matlab benchmark has caused some existential angst. \"Why is anyone even doing this? is it just a cute coincidence that if you take a subcategory of the yoneda embedding you preserve the ability to express dynamical systems? is this actually practical?\" etc.</p>",
        "id": 353931800,
        "sender_full_name": "André Muricy Santos",
        "timestamp": 1682695418
    },
    {
        "content": "<p>I love this question!</p>\n<p>... I probably have some things to say about it, but probably not until tomorrow</p>",
        "id": 353933261,
        "sender_full_name": "Jules Hedges",
        "timestamp": 1682695564
    },
    {
        "content": "<p>i should note that I have been a programmer for 11 years and have only gotten into category theory about a year ago (and in a very leisurely way. watching bartosz lectures and \"reading\" topos blog posts without understanding anything). i'm sure i don't have the instincts that someone like Spivak has but i feel like by now I <em>should</em> have \"seen the light\" and somehow grasped how obviously better Poly is for expressing certain things (i.e. it actually is more natural/practical).</p>",
        "id": 353934268,
        "sender_full_name": "André Muricy Santos",
        "timestamp": 1682695679
    },
    {
        "content": "<p>It would be very helpful to know a bit more about what you're doing, ie. what kind of things you're modelling and why, and what language, libraries etc you're using</p>",
        "id": 354441243,
        "sender_full_name": "Jules Hedges",
        "timestamp": 1682782873
    },
    {
        "content": "<p>I'd guess that quite a lot of your trouble is coming from the general phenomenon of compositional modelling being very hard at first. It's kinda like learning OOP all over again, except you have to invent all your own design patterns because nothing is standardised yet</p>",
        "id": 354441716,
        "sender_full_name": "Jules Hedges",
        "timestamp": 1682782940
    },
    {
        "content": "<p>For comparison: I'm not using Poly, but I'm using categories of optics which are closely related and share many of the same features. We use Haskell with a hand-rolled implementation of optics, with the core stuff using optics but not hesitating to fall back to plain Haskell whenever it's more convenient for something</p>",
        "id": 354442598,
        "sender_full_name": "Jules Hedges",
        "timestamp": 1682783081
    },
    {
        "content": "<p>The fact that all the data in Poly is \"really\" just data in Set is a general fact, if you push this to the extreme it becomes the straw-man argument \"why are you using language X, assembly/Fortran/C/etc is Turing complete so you can just work there\". At the other extreme there are also usually good reasons not to work in the most advanced language available (this fact applies to mathematics as well as software engineering!) - so everybody has to make a non-trivial engineering choice for these kind of tradeoffs</p>",
        "id": 354443965,
        "sender_full_name": "Jules Hedges",
        "timestamp": 1682783286
    },
    {
        "content": "<p>I'll need some time to collect my thoughts in order to properly reply as well. in particular i want to actually finish this damn thing. will probably say more tomorrow <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 354489023,
        "sender_full_name": "André Muricy Santos",
        "timestamp": 1682791045
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"275901\">Jules Hedges</span> <a href=\"#narrow/stream/229156-practice.3A-applied-ct/topic/how.20good.20is.20Poly.20for.20dynamical.20systems.2C.20really.3F/near/354443965\">said</a>:</p>\n<blockquote>\n<p>The fact that all the data in Poly is \"really\" just data in Set is a general fact, if you push this to the extreme it becomes the straw-man argument \"why are you using language X, assembly/Fortran/C/etc is Turing complete so you can just work there\". At the other extreme there are also usually good reasons not to work in the most advanced language available (this fact applies to mathematics as well as software engineering!) - so everybody has to make a non-trivial engineering choice for these kind of tradeoffs</p>\n</blockquote>\n<p>I do want to say that yes, i understand this, i didn't make my point very well very well. I guess i was attempting to contrast <em>the difficulty</em> i'm facing in actually writing code using Poly with <em>how naturally it \"claims\" to be able to represent the things im trying to represent</em>. I tend to roughly interpret \"this framework is good for expressing X\" as \"this framework has a very nice type system\", which is why i mentioned type safety in haskell.</p>",
        "id": 354490353,
        "sender_full_name": "André Muricy Santos",
        "timestamp": 1682791305
    },
    {
        "content": "<p>I'll point out this wouldn't be the case if one were working in a programming language which 'compiles' to Poly. Instead, atm one has to manually be the compiler and that impacts the practical appeal of Poly constructions. But this is not specific to Poly, but to every category whose internal language is simple and expressive but different from standard type theory.</p>",
        "id": 355269458,
        "sender_full_name": "Matteo Capucci (he/him)",
        "timestamp": 1683063206
    },
    {
        "content": "<p>The real deal is programming <em>in</em> the categories one'd like to use, but that's mostly sci-fi currently</p>",
        "id": 355269514,
        "sender_full_name": "Matteo Capucci (he/him)",
        "timestamp": 1683063238
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"275932\">Matteo Capucci (he/him)</span> <a href=\"#narrow/stream/229156-practice.3A-applied-ct/topic/how.20good.20is.20Poly.20for.20dynamical.20systems.2C.20really.3F/near/355269458\">said</a>:</p>\n<blockquote>\n<p>I'll point out this wouldn't be the case if one were working in a programming language which 'compiles' to Poly. Instead, atm one has to manually be the compiler and that impacts the practical appeal of Poly constructions. But this is not specific to Poly, but to every category whose internal language is simple and expressive but different from standard type theory.</p>\n</blockquote>\n<p>What you are really saying here is that the bare minimum to make category theory useful in software applications is:</p>\n<ul>\n<li>Implementing the categorical machinery in some language (usually a functional one for peace of mind, but this is not strictly needed)</li>\n<li>Implementing a decent DSL to make the most of the given functionality.</li>\n</ul>\n<p>In general, any programmer will concur on the fact that the 'language' (or more appropriately 'the core machinery' in this case) is just the tip of the iceberg. There's a lot of stuff around it to make the language practically useful, the bare minimum probably being a linter, a packet manager, syntax highlighting, virtual envs etc.</p>\n<p>So 'we can do dynamical systems with Poly' won't be really 'we can do dynamical systems with Poly' until all these further pieces of the ecosystem are implemented. And that takes time.</p>",
        "id": 355273721,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1683065190
    },
    {
        "content": "<p>If you want a real-world example of how this looks in practice, take a look at Rust. Rust has probably the most well-developed infrastructure around at the moment, and represents a good standard of 'how these things should look like in the best possible scenario'. If you come from Haskell, which is already a language with a quite developed ecosystem, programming in Rust will basically feel like magic.</p>",
        "id": 355274192,
        "sender_full_name": "Fabrizio Genovese",
        "timestamp": 1683065407
    }
]