[
    {
        "content": "<p>As much as I love the category, I'm noticing how bizarrely frustrating it is to write a mode-dependent dynamical systems (a reservoir computer in my case) using Poly constructs. When it comes to generating actual numbers for something nontrivial, debugging becomes a nightmare. It takes several minutes to do the plumbing necessary just to get the outer system to output information I can actually analyze.</p>\n<p>Something obvious only happened to occurr to me this week: there's nothing Poly can do that Set can't, really. A dynamical system is just a morphism? Great, it actually is just a morphism in Set also (albeit one that is a giant composition of functions). If you care about type safety, just write Haskell code and use Debug.trace when developing something.</p>\n<p>I'm asking this with love of course. I've been excited about the category and have loved working with it, but debugging it versus debugging a little matlab benchmark has caused some existential angst. \"Why is anyone even doing this? is it just a cute coincidence that if you take a subcategory of the yoneda embedding you preserve the ability to express dynamical systems? is this actually practical?\" etc.</p>",
        "id": 353931800,
        "sender_full_name": "André Muricy Santos",
        "timestamp": 1682695418
    },
    {
        "content": "<p>I love this question!</p>\n<p>... I probably have some things to say about it, but probably not until tomorrow</p>",
        "id": 353933261,
        "sender_full_name": "Jules Hedges",
        "timestamp": 1682695564
    },
    {
        "content": "<p>i should note that I have been a programmer for 11 years and have only gotten into category theory about a year ago (and in a very leisurely way. watching bartosz lectures and \"reading\" topos blog posts without understanding anything). i'm sure i don't have the instincts that someone like Spivak has but i feel like by now I <em>should</em> have \"seen the light\" and somehow grasped how obviously better Poly is for expressing certain things (i.e. it actually is more natural/practical).</p>",
        "id": 353934268,
        "sender_full_name": "André Muricy Santos",
        "timestamp": 1682695679
    },
    {
        "content": "<p>It would be very helpful to know a bit more about what you're doing, ie. what kind of things you're modelling and why, and what language, libraries etc you're using</p>",
        "id": 354441243,
        "sender_full_name": "Jules Hedges",
        "timestamp": 1682782873
    },
    {
        "content": "<p>I'd guess that quite a lot of your trouble is coming from the general phenomenon of compositional modelling being very hard at first. It's kinda like learning OOP all over again, except you have to invent all your own design patterns because nothing is standardised yet</p>",
        "id": 354441716,
        "sender_full_name": "Jules Hedges",
        "timestamp": 1682782940
    },
    {
        "content": "<p>For comparison: I'm not using Poly, but I'm using categories of optics which are closely related and share many of the same features. We use Haskell with a hand-rolled implementation of optics, with the core stuff using optics but not hesitating to fall back to plain Haskell whenever it's more convenient for something</p>",
        "id": 354442598,
        "sender_full_name": "Jules Hedges",
        "timestamp": 1682783081
    },
    {
        "content": "<p>The fact that all the data in Poly is \"really\" just data in Set is a general fact, if you push this to the extreme it becomes the straw-man argument \"why are you using language X, assembly/Fortran/C/etc is Turing complete so you can just work there\". At the other extreme there are also usually good reasons not to work in the most advanced language available (this fact applies to mathematics as well as software engineering!) - so everybody has to make a non-trivial engineering choice for these kind of tradeoffs</p>",
        "id": 354443965,
        "sender_full_name": "Jules Hedges",
        "timestamp": 1682783286
    },
    {
        "content": "<p>I'll need some time to collect my thoughts in order to properly reply as well. in particular i want to actually finish this damn thing. will probably say more tomorrow <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 354489023,
        "sender_full_name": "André Muricy Santos",
        "timestamp": 1682791045
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"275901\">Jules Hedges</span> <a href=\"#narrow/stream/229156-practice.3A-applied-ct/topic/how.20good.20is.20Poly.20for.20dynamical.20systems.2C.20really.3F/near/354443965\">said</a>:</p>\n<blockquote>\n<p>The fact that all the data in Poly is \"really\" just data in Set is a general fact, if you push this to the extreme it becomes the straw-man argument \"why are you using language X, assembly/Fortran/C/etc is Turing complete so you can just work there\". At the other extreme there are also usually good reasons not to work in the most advanced language available (this fact applies to mathematics as well as software engineering!) - so everybody has to make a non-trivial engineering choice for these kind of tradeoffs</p>\n</blockquote>\n<p>I do want to say that yes, i understand this, i didn't make my point very well very well. I guess i was attempting to contrast <em>the difficulty</em> i'm facing in actually writing code using Poly with <em>how naturally it \"claims\" to be able to represent the things im trying to represent</em>. I tend to roughly interpret \"this framework is good for expressing X\" as \"this framework has a very nice type system\", which is why i mentioned type safety in haskell.</p>",
        "id": 354490353,
        "sender_full_name": "André Muricy Santos",
        "timestamp": 1682791305
    }
]